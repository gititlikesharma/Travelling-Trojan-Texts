/*	8 Queens.c
	Solve 8 Queens Problem using Backtracking
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/

#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define MAXCANDIDATES   100     /* max possible next extensions */
#define NMAX            100     /* maximum solution size */
bool finished = false;
int solution_count;             /* how many solutions are there ? */
void process_solution(int a[], int k, int input) {
    solution_count ++;
}
int is_a_solution(int a[], int k, int n) {
    return (k == n);
}
void make_move(int a[], int k, int n) {
}
void unmake_move(int a[], int k, int n) {
}
/*  What are possible elements of the next slot in the 8-queens problem ? */
void construct_candidates(int a[], int k, int n, int c[], int *ncandidates) {
    int i, j;               /* counters */
    bool legal_move;        /* might the move be legal ? */
    *ncandidates = 0;
    for (i = 1; i <= n; i++) {
        legal_move = true;
        for (j = 1; j < k; j++) {
            if (abs((k)-j) == abs(i-a[j])) {    /* diagonal threat */
                legal_move = false;
            }
			if (i == a[j]) {                    /* column threat */
                legal_move = false;
            }
        }
        if (legal_move) {
            c[*ncandidates] = i;
            *ncandidates = *ncandidates + 1;
        }
    }
}
void backtrack(int a[], int k, int input) {
    int c[MAXCANDIDATES];           /* candidates for next position */
    int ncandidates;                /* next position candidate count */
    int i;                          /* counter */
    if (is_a_solution(a, k, input)) {
        process_solution(a, k, input);
    } else {
        k = k + 1;
        construct_candidates(a,k,input,c,&ncandidates);
        for (i = 0; i < ncandidates; i++) {
            a[k] = c[i];
            make_move(a, k, input);
            backtrack(a, k, input);
            unmake_move(a, k, input);
            if (finished) {
                return;             /* terminate early */
            }
        }
    }
}
int main(void) {
    int a[NMAX];        /* solution vector */
    int i;              /* counter */
    for (i = 1; i <= 10; i++) {
        solution_count = 0;
        backtrack(a, 0, i);
        printf("n=%d  solution_count=%d\n", i, solution_count);
    }
    return 0;
}

/*	bignum.c
	Large Integer Arithmetic : Addition, Subtraction, Multiplication, and Division.
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#include <stdlib.h>
#define	MAXDIGITS   100     /* maximum length bignum */ 
#define PLUS        1       /* positive sign bit */
#define MINUS       -1      /* negative sign bit */
typedef struct {
    char digits[MAXDIGITS]; /* represent the number */
    int signbit;            /* 1 if positive, -1 if negative */ 
    int lastdigit;          /* index of high-order digit */
} bignum;
void add_bignum(bignum *a, bignum *b, bignum *c);
void print_bignum(bignum *n) {
    int i;
    if (n->signbit == MINUS) {
        printf("- ");
    }
    for (i = n->lastdigit; i >= 0; i--) {
        printf("%c",'0'+ n->digits[i]);
    }
    printf("\n");
}
void zero_justify(bignum *n) {
    while ((n->lastdigit > 0) && (n->digits[ n->lastdigit ] == 0)) {
        n->lastdigit--;
    }
    if ((n->lastdigit == 0) && (n->digits[0] == 0)) {
        n->signbit = PLUS;	/* hack to avoid -0 */
    }
}
void int_to_bignum(int s, bignum *n) {
    int i;    /* counter */
    int t;    /* int to work with */
    if (s >= 0) {
        n->signbit = PLUS;
    } else {
        n->signbit = MINUS;
    }
    for (i = 0; i < MAXDIGITS; i++) {
        n->digits[i] = (char) 0;
    }
    n->lastdigit = -1;
    t = abs(s);
    while (t > 0) {
        n->lastdigit ++;
        n->digits[n->lastdigit] = (t % 10);
        t = t / 10;
	}
    if (s == 0) {
        n->lastdigit = 0;
    }
}
void initialize_bignum(bignum *n) {
    int_to_bignum(0, n);
}
int max(int a, int b) {
    if (a > b) {
        return(a);
    }
    return(b);
}
int compare_bignum(bignum *a, bignum *b) {
    int i;    /* counter */
    if ((a->signbit == MINUS) && (b->signbit == PLUS)) {
        return(PLUS);
    }
    if ((a->signbit == PLUS) && (b->signbit == MINUS)) {
        return(MINUS);
    }
    if (b->lastdigit > a->lastdigit) {
        return (PLUS * a->signbit);
    }
    if (a->lastdigit > b->lastdigit) {
        return (MINUS * a->signbit);
    }
    for (i = a->lastdigit; i >= 0; i--) {
        if (a->digits[i] > b->digits[i]) {
            return(MINUS * a->signbit);
        }
        if (b->digits[i] > a->digits[i]) {
            return(PLUS * a->signbit);
        }
	}
    return(0);
}
void subtract_bignum(bignum *a, bignum *b, bignum *c) {
    int borrow;         /* has anything been borrowed? */
    int v;              /* placeholder digit */
    int i;              /* counter */
    initialize_bignum(c);
    if ((a->signbit == MINUS) || (b->signbit == MINUS)) {
        b->signbit = -1 * b->signbit;
        add_bignum(a, b, c);
        b->signbit = -1 * b->signbit;
        return;
    }
    if (compare_bignum(a, b) == PLUS) {
        subtract_bignum(b, a, c);
        c->signbit = MINUS;
        return;
    }
    c->lastdigit = max(a->lastdigit, b->lastdigit);
    borrow = 0;
    for (i = 0; i <= (c->lastdigit); i++) {
        v = (a->digits[i] - borrow - b->digits[i]);
        if (a->digits[i] > 0) {
            borrow = 0;
        }
        if (v < 0) {
            v = v + 10;
            borrow = 1;
        }
        c->digits[i] = (char) v % 10;
    }
    zero_justify(c);
}
void add_bignum(bignum *a, bignum *b, bignum *c) {
    int carry;          /* carry digit */
    int i;              /* counter */
    initialize_bignum(c);
    if (a->signbit == b->signbit) {
        c->signbit = a->signbit;
    } else {
        if (a->signbit == MINUS) {
            a->signbit = PLUS;
            subtract_bignum(b, a, c);
            a->signbit = MINUS;
        } else {
            b->signbit = PLUS;
            subtract_bignum(a, b, c);
            b->signbit = MINUS;
        }
        return;
    }
    c->lastdigit = max(a->lastdigit, b->lastdigit) + 1;
    carry = 0;
    for (i = 0; i <= (c->lastdigit); i++) {
        c->digits[i] = (char) (carry + a->digits[i] + b->digits[i]) % 10;
        carry = (carry + a->digits[i] + b->digits[i]) / 10;
    }
    zero_justify(c);
}
void digit_shift(bignum *n, int d) {
    int i;    /* counter */
    if ((n->lastdigit == 0) && (n->digits[0] == 0)) {
        return;
    }
    for (i = n->lastdigit; i >= 0; i--) {
        n->digits[i + d] = n->digits[i];
    }
    for (i = 0; i < d; i++) {
        n->digits[i] = 0;
    }
    n->lastdigit = n->lastdigit + d;
}
void multiply_bignum(bignum *a, bignum *b, bignum *c) {
    bignum row;         /* represent shifted row */
    bignum tmp;         /* placeholder bignum */
    int i, j;           /* counters */
    initialize_bignum(c);
    row = *a;
    for (i = 0; i <= b->lastdigit; i++) {
        for (j = 1; j <= b->digits[i]; j++) {
            add_bignum(c, &row, &tmp);
            *c = tmp;
        }
        digit_shift(&row, 1);
    }
    c->signbit = a->signbit * b->signbit;
    zero_justify(c);
}
void divide_bignum(bignum *a, bignum *b, bignum *c) {
    bignum row;                     /* represent shifted row */
    bignum tmp;                     /* placeholder bignum */
    int asign, bsign;               /* temporary signs */
    int i;                          /* counters */
    initialize_bignum(c);
    c->signbit = a->signbit * b->signbit;
    asign = a->signbit;
    bsign = b->signbit;
    a->signbit = PLUS;
    b->signbit = PLUS;
    initialize_bignum(&row);
    initialize_bignum(&tmp);
    c->lastdigit = a->lastdigit;
    for (i = a->lastdigit; i >= 0; i--) {
        digit_shift(&row, 1);
        row.digits[0] = a->digits[i];
        c->digits[i] = 0;
        while (compare_bignum(&row, b) != PLUS) {
            c->digits[i] ++;
            subtract_bignum(&row, b, &tmp);
            row = tmp;
        }
    }
    zero_justify(c);
    a->signbit = asign;
    b->signbit = bsign;
}
int main(void) {
    int a,b;
    bignum n1, n2, n3, zero;
    while (scanf("%d %d\n",&a,&b) != EOF) {
        printf("A = %d    B = %d\n", a, b);
        int_to_bignum(a, &n1);
        int_to_bignum(b, &n2);
        add_bignum(&n1, &n2, &n3);
        printf("Addition -- ");
        print_bignum(&n3);
        printf("compare_bignum a ? b = %d\n", compare_bignum(&n1, &n2));
        subtract_bignum(&n1, &n2, &n3);
        printf("Subtraction -- ");
        print_bignum(&n3);
        multiply_bignum(&n1, &n2, &n3);
        printf("Multiplication -- ");
        print_bignum(&n3);
        int_to_bignum(0, &zero);
        if (compare_bignum(&zero, &n2) == 0) {
            printf("Division -- NaN \n");
        } else {
            divide_bignum(&n1, &n2, &n3);
            printf("Division -- ");
            print_bignum(&n3);
        }
        printf("--------------------------\n");
    }
}

/*	binomial.c
	Compute the Binomial Coefficients using Dynamic Programming 
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#define	MAXN    100    /* largest n or k */
long binomial_coefficient(int n, int k) {
    int i, j;                   /* counters */
    long bc[MAXN+1][MAXN+1];    /* binomial coefficient table */
    for (i = 0; i <= n; i++) {
        bc[i][0] = 1;
    }
    for (j = 0; j <= n; j++) {
        bc[j][j] = 1;
    }
    for (i = 2; i <= n; i++) {
        for (j = 1; j < i; j++) {
            bc[i][j] = bc[i-1][j-1] + bc[i-1][j];
        }
    }
    return(bc[n][k]);
}
int main(void) {
    int a, b, n, i;
    scanf("%d", &n);
    for (i=0; i<n; i++) {
        scanf("%d %d", &a, &b);
        printf("%d Choose %d = %ld\n", a, b, binomial_coefficient(a, b));
    }
    return 0;
}

/*	convolve.c
	Compute the Convolution Function of 2 Sequences
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#define	MAXN    100      /* largest n or m */
int max(int x, int y) {
    if (x > y) return(x); else return(y);
}
int min(int x, int y) {
    if (x < y) return(x); else return(y);
}
int main(void) {
    int i, j;                       /* counters */
    int a[MAXN],b[MAXN],c[MAXN];    /* sequences */
    int n, m;                       /* sequence lengths */
    for (i = 0; i < MAXN; i++) {
        a[i] = b[i] = c[i] = 0;
    }
    scanf("%d",&m);
    for (i=0; i < m; i++) {
	scanf("%d",&a[i]);
    }
    scanf("%d",&n);
    for (i=0; i < n; i++) {
        scanf("%d",&b[i]);
    }
    for (i = 0; i < n+m-1; i++) {
        for (j = max(0,i-(n-1)); j <= min(m-1,i); j++) {
	    c[i] = c[i] + a[j] * b[i-j];
	}
    }
for (i=0; i < m+n-1; i++) {
	printf("%d ",c[i]);
}
printf("\n");
return 0;
}

/*	elevator.c
	Elevator Stop Optimization via Dynamic Programming.
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#define	NFLOORS     25  /* the height of the building in floors */
#define MAX_RIDERS  50  /* what is the capacity of the elevator ? */
#define MAXINT      100007
int stops[MAX_RIDERS];  /* what floor does everyone get off at ? */
int nriders;            /* number of riders */
int nstops;             /* number of allowable stops */
int m[NFLOORS+1][MAX_RIDERS];   /* dynamic programming cost table */
int p[NFLOORS+1][MAX_RIDERS];   /* dynamic programming parent table */
int min(int a, int b) {
	if (a < b) {
        return(a); 
    }
    return(b);
}
int floors_walked(int previous, int current) {
    int nsteps=0;   /* total distance traveled */
    int i;          /* counter */
    for (i = 1; i <= nriders; i++) {
        if ((stops[i] > previous) && (stops[i] <= current)) {
            nsteps += min(stops[i]-previous, current-stops[i]);
        }
    }
    return(nsteps);
}
/*	m[i][j] denotes the cost of serving all the riders using j stops, the last of which is at floor i.  Zero is the originating floor. */
int optimize_floors() {
    int i, j, k;    /* counters */
    int cost;       /* costs placeholder */
    int laststop;   /* the elevator's last stop */
    for (i = 0; i <= NFLOORS; i++) {
        m[i][0] = floors_walked(0, MAXINT);
        p[i][0] = -1;
    }
    for (j = 1; j <= nstops; j++) { 
        for (i = 0; i <= NFLOORS; i++) {
            m[i][j] = MAXINT;
            for (k = 0; k <= i; k++) {
                cost = m[k][j-1] - floors_walked(k, MAXINT) +
                floors_walked(k, i) + floors_walked(i, MAXINT);
                if (cost < m[i][j]) {
                    m[i][j] = cost;
                    p[i][j] = k;
                }    
            }
        }
    }
    laststop = 0;
    for (i = 1; i <= NFLOORS; i++) { 
        if (m[i][nstops] < m[laststop][nstops]) {
            laststop = i;
        }
    }
    return(laststop);
}
void reconstruct_path(int lastfloor, int stops_to_go) {
    if (stops_to_go > 1) {
        reconstruct_path(p[lastfloor][stops_to_go], stops_to_go-1);
    }
    printf("%d\n", lastfloor);
}
void print_matrix(int m[NFLOORS+1][MAX_RIDERS]) {
    int i, j;    /* counters */
    for (j = 0; j <= nstops; j++) {
        for (i = 0; i <= NFLOORS; i++) {
            printf("%3d", m[i][j]);
        }
        printf("\n");
    }
}
int main(void) {
    int i;        /* counter */
    int laststop;
    scanf("%d %d", &nriders, &nstops);
    for (i = 1; i <= nriders; i++) {
        scanf("%d", &(stops[i]));
    }
    for (i = 1; i <= nriders; i++) {
        printf("%d\n", stops[i]);
    }
    laststop = optimize_floors();
    print_matrix(m);
    printf("\n");
    print_matrix(p);
    printf("cost = %d\n", m[laststop][nstops]);
    reconstruct_path(laststop, nstops);
    return 0;
}

/*	floyd.c
	Compute All Pairs Shortest Paths in weighted Graphs
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#define	MAXV        100     /* maximum number of vertices */
#define MAXDEGREE   50      /* maximum outdegree of a vertex */
#define MAXINT      100007
typedef struct {
    int v;              /* neighboring vertex */
    int weight;         /* edge weight */
    bool in;            /* is the edge "in" the solution? */
} edge;
typedef struct {
    edge edges[MAXV+1][MAXDEGREE];  /* adjacency info */
    int degree[MAXV+1];             /* outdegree of each vertex */
    int nvertices;                  /* number of vertices in graph */
    int nedges;                     /* number of edges in the graph */
} graph;
typedef struct {
    int weight[MAXV+1][MAXV+1];  /* adjacency/weight info */
    int nvertices;               /* number of vertices in graph */
} adjacency_matrix;
void initialize_adjacency_matrix(adjacency_matrix *g) {
    int i, j;    /* counters */
    g->nvertices = 0;
    for (i = 1; i <= MAXV; i++) {
        for (j = 1; j <= MAXV; j++) {
            g->weight[i][j] = MAXINT;
        }
    }
}
void read_adjacency_matrix(adjacency_matrix *g, bool directed) {
    int i;              /* counter */
    int m;              /* number of edges */
    int x, y, w;        /* placeholder for edge and weight */
    initialize_adjacency_matrix(g);
    scanf("%d %d\n", &(g->nvertices), &m);
    for (i = 1; i <= m; i++) {
        scanf("%d %d %d\n", &x, &y, &w);
        g->weight[x][y] = w;
        if (!directed) {
            g->weight[y][x] = w;
        }
    }
}
void print_graph(adjacency_matrix *g) {
    int i, j;    /* counters */
    for (i = 1; i <= g->nvertices; i++) {
        printf("%d: ",i);
        for (j = 1; j <= g->nvertices; j++) {
            if (g->weight[i][j] < MAXINT) {
                printf(" %d",j);
            }
        }
        printf("\n");
    }
}
void print_adjacency_matrix(adjacency_matrix *g) {
    int i, j;    /* counters */
    for (i = 1; i <= g->nvertices; i++) {
        printf("%3d: ",i);
        for (j = 1; j <= g->nvertices; j++) {
            printf(" %3d", g->weight[i][j]);
        }
        printf("\n");
    }
}
void floyd(adjacency_matrix *g) {
    int i, j;           /* dimension counters */
    int k;              /* intermediate vertex counter */
    int through_k;      /* distance through vertex k */
    for (k = 1; k <= g->nvertices; k++) {
        for (i = 1; i <= g->nvertices; i++) {
            for (j = 1; j <= g->nvertices; j++) {
                through_k = g->weight[i][k]+g->weight[k][j];
                if (through_k < g->weight[i][j]) {
                    g->weight[i][j] = through_k;
                }
	    }
	}
    }
}
int main(void) {
    adjacency_matrix g;
    read_adjacency_matrix(&g, false);
    print_graph(&g);
    floyd(&g);
    print_adjacency_matrix(&g);
    return 0;
}

/*	gcd.c           
	Compute GCD of 2 Integers
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <math.h>
#include <stdio.h>
long gcd1(long p, long q) {
    if (q > p) {
        return(gcd1(q, p));
    }
    if (q == 0) {
        return(p);
    }
    printf(" gcd(%ld,%ld) &=& gcd(%ld \\mod %ld, %ld) = gcd(%ld,%ld) \n",
            p, q, p, q, q, q, p % q);
    return(gcd1(q, p % q));
}
long gcd(long p, long q, long *x, long *y) {
    long x1, y1;        /* previous coefficients */
    long g;             /* value of gcd(p,q) */
    if (q > p) {
        return(gcd(q, p, y, x));
    }
    if (q == 0) {
        *x = 1;
        *y = 0;
        return(p);
    }
    g = gcd(q, p%q, &x1, &y1);	
    *x = y1;
    *y = (x1 - floor(p/q)*y1);
    return(g);
}
int main(void) {
    long p, q;
    long x, y, g1, g2;
    while (scanf("%ld %ld", &p, &q) != EOF) {
        g1 = gcd1(p, q);
        g2 = gcd(p, q, &x, &y);
        printf("GCD of p=%ld and q=%ld = %ld\n", p, q, g1);
        printf(" %ld*%ld + %ld*%ld = %ld\n", p, x, q, y, g2);
        if (g1 != g2) {
            printf("ERROR: GCD can't be Computed !\n");
        }        
        if ((p*x + q*y) != g1) {
            printf("Error: Diophonine Solution is Wrong !\n");
        }
    }
    return 0;
}

/*	matrix.c
	Multiply 2 Matrices
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#include <stdlib.h>
#define	MAXV        100     /* maximum number of vertices */
#define MAXDEGREE   50      /* maximum outdegree of a vertex */
#define MAXINT      100007
typedef struct {
    int m[MAXV+1][MAXV+1];  /* adjacency/weight info */
    int rows;               /* number of rows */
    int columns;            /* number of columns */
} matrix;
void initialize_matrix(matrix *m) {
    int i, j;    /* counters */
    for (i = 1; i <= m->rows; i++) {
        for (j = 1; j <= m->columns; j++) {
            m->m[i][j] = 0;
        }
    }
}
void read_matrix(matrix *m) {
    int i, j;    /* counters */
    scanf("%d %d\n", &(m->rows), &(m->columns));
    for (i = 1; i <= m->rows; i++) {
        for (j = 1; j <= m->columns; j++) {
            scanf("%d", &m->m[i][j]);
        }
    }
}
void print_matrix(matrix *g) {
    int i, j;    /* counters */
    for (i = 1; i <= g->rows; i++) {
        for (j = 1; j <= g->columns; j++) {
            printf(" %d",g->m[i][j]);
        }
        printf("\n");
    }
    printf("\n");
}
void multiply(matrix *a, matrix *b, matrix *c) {
    int i, j, k;    /* dimension counters */
    if (a->columns != b->rows) {
        printf("Error: bounds dont match!\n");
        return;
    }
    c->rows = a->rows;
    c->columns = b->columns;
    for (i = 1; i <= a->rows; i++) {
        for (j = 1; j <= b->columns; j++) {
            c->m[i][j] = 0;
            for (k = 1; k <= b->rows; k++) {
                c->m[i][j] += a->m[i][k] * b->m[k][j];
            }
        }
    }
}
int main(void) {
    matrix a, b, c;
    read_matrix(&a);
    print_matrix(&a);
    read_matrix(&b);
    print_matrix(&b);
    multiply(&a, &b, &c);
    print_matrix(&c);
    return 0;
}

/*    name.c
      Corporate Name Changing Program
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#include <string.h>
#define MAXLEN      1001   /* longest possible string */
#define MAXCHANGES  101    /* maximum number of name changes */
typedef char string[MAXLEN];
string mergers[MAXCHANGES][2];   /* store before/after corporate names */
int nmergers;                    /* the number of different name changes */
void read_quoted_string(char *s) {
    int i = 0;      /* counter */
    char c;         /* latest character */
    while ((c = getchar()) != '\"')
        ;
    while ((c = getchar()) != '\"') {
        s[i] = c;
        i = i + 1;
    }
    s[i] = '\0';
}
void read_changes(void) {
    int i;    /* counter */
    scanf("%d\n", &nmergers);
    for (i = 0; i<nmergers; i++) {
        read_quoted_string((char*)&(mergers[i][0]));
        read_quoted_string((char*)&(mergers[i][1]));
    }
}
/*    Replace the substring of length xlen starting at position pos in string s with the contents of string y. */
void replace_x_with_y(char *s, int pos, int xlen, char *y) {
    int i;            /* counter */
    int slen,ylen;    /* lengths of relevant strings */
    slen = strlen(s);
    ylen = strlen(y);
    if (xlen >= ylen) {
        for (i = (pos+xlen); i <= slen; i++) {
            s[i+(ylen-xlen)] = s[i];
        }
    } else {
        for (i = slen; i >= (pos+xlen); i--) {
            s[i+(ylen-xlen)] = s[i];
        }
    }
    for (i = 0; i < ylen; i++) {
        s[pos+i] = y[i];
    }
}
/*    Return the position of the first occurrence of the pattern p in the text t, and -1 if it does not occur. */
int findmatch(char *p, char *t) {
    int i, j;          /* counters */
    int plen, tlen;    /* string lengths */
    plen = strlen(p);
    tlen = strlen(t);
    for (i = 0; i <= (tlen-plen); i = i + 1) {
        j = 0;
        while ((j < plen) && (t[i + j] == p[j])) {
            j = j + 1;
        }
        if (j == plen) {
            return(i);  /* location of the first match */
        }
    }
    return(-1);         /* there is no match */
}
int main(void) {
    string s;    /* input string */
    char c;      /* input character */
    int nlines;  /* number of lines in text */
    int i,j;     /* counters */
    int pos;     /* position of pattern in string */
    read_changes();
    scanf("%d\n", &nlines);
    for (i = 1; i <= nlines; i = i + 1) {
        /* read text line */
        j = 0;
        while ((c = getchar()) != '\n') {
            s[j] = c;
            j = j + 1;
        }
        s[j] = '\0';
        for (j = 0; j < nmergers; j = j + 1) {
            while ((pos=findmatch(mergers[j][0], s)) != -1) {
                replace_x_with_y(s, pos, strlen(mergers[j][0]), mergers[j][1]);
            }
        }
        printf("%s\n", s);
    }
    return 0;
}

/*    permutations.c
      Construct all Permutations via Backtracking.
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#include <stdbool.h>
#define MAXCANDIDATES   100    /* max possible next extensions */
#define NMAX            100    /* maximum solution size */
bool finished = false;
void process_solution(int a[], int k, int input) {
    int i;    /* counter */
    for (i = 1; i <= k; i++) {
        printf(" %d", a[i]);
    }
    printf("\n");
}
int is_a_solution(int a[], int k, int n) {
    return (k == n);
}
void make_move(int a[], int k, int n) {
}
void unmake_move(int a[], int k, int n){
}
/*    What are possible elements of the next slot in the permutation ?  */
void construct_candidates(int a[], int k, int n, int c[], int *nc) {
    int i;                 /* counter */
    bool in_perm[NMAX];    /* what is now in the permutation? */
    for (i = 1; i < NMAX; i++) {
        in_perm[i] = false;
    }
    for (i = 1; i < k; i++) {
        in_perm[a[i]] = true;
    }
    *nc = 0;
    for (i = 1; i <= n; i++) { 
        if (!in_perm[i]) {
            c[ *nc ] = i;
            *nc = *nc + 1;
        }
    }
}
void backtrack(int a[], int k, int input) {
    int c[MAXCANDIDATES];           /* candidates for next position */
    int ncandidates;                /* next position candidate count */
    int i;                          /* counter */
    if (is_a_solution(a, k, input)) {
        process_solution(a, k, input);
    } else {
        k = k + 1;
        construct_candidates(a, k, input, c, &ncandidates);
        for (i = 0; i < ncandidates; i++) {
            a[k] = c[i];
            make_move(a, k, input);
            backtrack(a, k, input);
            unmake_move(a, k, input);
            if (finished) {
                return;    /* terminate early */
            }
        }
    }
}
void generate_permutations(int n) {
    int a[NMAX];                    /* solution vector */
    backtrack(a, 0, n);
}
int main(void) {
    generate_permutations(0);
    generate_permutations(1);
    generate_permutations(2);
    generate_permutations(3);
    return 0;
}

/*    plates.c
    Compute the Number of Circles in 2 different Disk Packings.
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#include <math.h>
int dense_layers(double w, double h, double r) {
    double gap;    /* distance between layers */
    if ((2*r) > h) {
        return(0);
    }
    gap = 2.0 * r * (sqrt(3)/2.0);
    return(1 + floor((h - 2.0 * r) / gap));
}
int plates_per_row(int row, double w, double r) {
    int plates_per_full_row;    /* number of plates in full/even row */
    plates_per_full_row = floor(w / (2 * r));
    if ((row % 2) == 0) {
        return(plates_per_full_row);
    }
    if (((w/(2*r))-plates_per_full_row) >= 0.5) {    /* odd row full, too */
        return(plates_per_full_row);
    } else {
        return(plates_per_full_row - 1);
    }
}
/*
    How many radius r plates fit in a hexagonal-lattice packed w*h box ?
*/
int dense_plates(double w, double l, double r) {
    int layers;    /* number of layers of balls */
    layers = dense_layers(w, l, r);
    return (ceil(layers/2.0) * plates_per_row(0,w,r) +
    floor(layers/2.0) * plates_per_row(1,w,r) );
}
int grid_plates(double w, double h, double r) {
    int layers;    /* number of layers of balls */
    layers = floor(h / (2 * r));
    return (layers * plates_per_row(0, w, r));
}
/*  Hexagonal coordinates start with the center of disk (0,0) at
    geometric point (0,0).  The hexagonal coordinate $(xh,yh)$
    refers to the center of the disk on the horizontal row xh
    and positive-slope diagonal yh.   The geometric coordinate of
    such a point is a function of the radius of the disk $r$.
*/
void hex_to_geo(int xh, int yh, double r, double *xg, double *yg) {
    *yg = (2.0 * r) * xh * (sqrt(3)/2.0);
    *xg = (2.0 * r) * xh * (1.0/2.0) + (2.0 * r) * yh;
}
void geo_to_hex(double xg, double yg, double r, double *xh, double *yh) {
    *xh = (2.0/sqrt(3)) * yg / (2.0 * r);
    *yh = (xg - (2.0 * r) * (*xh) * (1.0/2.0) ) / (2.0 * r);
}
/*  Under the hexagonal coordinate system, the set of hexagons defined
    by coordinates (hx,hy), where $0 <= hx <= xmax$ and $0 <= hx <= ymax$
    forms a diamond-shaped patch, not a conventional axis-oriented 
    rectangle.  To solve this problem, we define array coordinates
    so that (ax,ay) refers to the position in an axis-oriented
    rectangle with (0,0) as the lower righthand point in the matrix.
*/
void array_to_hex(int xa, int ya, int *xh, int *yh) {
    *xh = xa;
    *yh = ya - xa + ceil(xa/2.0);
}
void hex_to_array(int xh, int yh, int *xa, int *ya) {
    *xa = xh;
    *ya = yh + xh - ceil(xh/2.0);
}
int plates_on_top(int xh, int yh, double w, double l, double r) {
    int number_on_top = 0;    /* total plates on top */
    int layers;               /* number of rows in grid */
    int rowlength;            /* number of plates in row */
    int row;                  /* counter */
    int xla, yla, xra, yra;   /* array coordinates */
    layers = dense_layers(w, l, r);
    for (row = xh + 1; row < layers; row++) {
        rowlength = plates_per_row(row, w, r) - 1;
        hex_to_array(row, yh - (row - xh), &xla, &yla);
        if (yla < 0) {
            yla = 0;    /* left boundary */
        }
        hex_to_array(row,yh,&xra,&yra);
        if (yra > rowlength) {
            yra = rowlength;    /* right boundary */
        }
        number_on_top += yra - yla + 1;
    }
    return(number_on_top);
}
int main(void) {
    double w;    /* box width */
    double l;    /* box length */
    double r;    /* plate radius */
    int i;       /* counters */
    int xmax, ymax;
    printf("Input Box Width, Box Length, and Plate Radius:\n");
    scanf("%lf %lf %lf", &w, &l, &r);
    printf("box width=%lf, box length=%lf, and plate radius=%lf:\n", w, l, r);
    printf("Dense Packing = %d\n", dense_plates(w, l, r));
    printf("Grid Packing = %d\n",  grid_plates(w, l, r));
    /* print all the possible hexes in the box */
    xmax = floor(w / (2*r));
    ymax = dense_layers(w,l,r);
    for (i = 0; i < xmax; i++) {
        printf("(0,%d) has %d on top\n", i, plates_on_top(0, i, w, l, r));
    }
    return 0;
}

/*    primes.c        
      Compute the Prime Factorization of an Integer.
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <math.h>
#include <stdio.h>
void prime_factorization(long x) {
    long i;    /* counter */
    long c;    /* remaining product to factor */
    c = x;
    while ((c % 2) == 0) {
        printf("%d\n", 2);
        c = c / 2;
    }
    i = 3;
    while (i <= (sqrt(c) + 1)) {
        if ((c % i) == 0) {
            printf("%ld\n", i);
            c = c / i;
        } else {
            i = i + 2;
        }
    }
    if (c > 1) {
        printf("%ld\n", c);
    }
}
int main(void) {
    long p;
    while (scanf("%ld", &p) != EOF) {
        printf("Prime Factorization of p=%ld \n", p);
        prime_factorization(p);
    }
    return 0;
}

/*    subsets.c
      Construct Subsets via Backtracking.
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#include <stdbool.h>
bool finished = false;
#define MAXCANDIDATES   100    /* max possible next extensions */
#define NMAX            100    /* maximum solution size */
void process_solution(int a[], int k, int input) {
    int i;    /* counter */    
    printf("{");
    for (i = 1; i <= k; i++) {
        if (a[i] == true) {
            printf(" %d", i);
        }
    }
    printf(" }\n");
}
void make_move(int a[], int k, int n) {
}
void unmake_move(int a[], int k, int n) {
}
/*    What are possible elements of the next slot in the permutation ?  */
int is_a_solution(int a[], int k, int n) {
    return (k == n);
}
void construct_candidates(int a[], int k, int n, int c[], int *nc) {
    c[0] = true;
    c[1] = false;
    *nc = 2;
}
void backtrack(int a[], int k, int input) {
    int c[MAXCANDIDATES];           /* candidates for next position */
    int ncandidates;                /* next position candidate count */
    int i;                          /* counter */
    if (is_a_solution(a, k, input)) {
        process_solution(a, k, input);
    } else {
        k = k + 1;
        construct_candidates(a, k, input, c, &ncandidates);
        for (i = 0; i < ncandidates; i++) {
            a[k] = c[i];
            make_move(a, k, input);
            backtrack(a, k, input);
            unmake_move(a, k, input);
            if (finished) {
                return;    /* terminate early */
            }
        }
    }
}
void generate_subsets(int n) {
    int a[NMAX];                    /* solution vector */
    backtrack(a, 0, n);
}
int main(void) {
    generate_subsets(3);
    return 0;
}

/*	subsetsum.c
	Solve Subset Sum Problem by Dynamic Programming
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#include <stdbool.h>
#define	MAXN    100    /* largest n */
#define MAXSUM	10000  /* largest sum we will consider */
#define NIL     -1
bool sum[MAXN+1][MAXSUM+1];     /* table of realizable sums */
int parent[MAXN+1][MAXSUM+1];   /* table of parent pointers */
bool subset_sum(int s[], int n, int k) {
    int i, j;                     /* counters */
    sum[0][0] = true;
    parent[0][0] = NIL;
    for (i = 1; i <= k; i++) {
        sum[0][i] = false;
	parent[0][i] = NIL;
    }
    for (i = 1; i <= n; i++) {    /* build table */
        for (j = 0; j <= k; j++) {
	    sum[i][j] = sum[i-1][j];
            parent[i][j] = NIL;
	    if ((j >= s[i-1]) && (sum[i-1][j-s[i-1]]==true)) {
		sum[i][j] = true;
		parent[i][j] = j-s[i-1];
	    }
        }
    }
    return(sum[n][k]);
}
void report_subset(int n, int k) {
   if (k == 0) {
	return;
   }
   if (parent[n][k] == NIL) {
	report_subset(n-1,k);
   }
   else {
	report_subset(n-1,parent[n][k]);
   	printf(" %d ",k-parent[n][k]);
   }
}
int main(void) {
    int r, n, k, i, s[MAXN+1], m, j;
    scanf("%d",&m);
    for (j=0; j<m; j++) {    
    	scanf("%d %d", &n, &k);
        printf("n=%d  k=%d \n",n,k);
    	for (i=0; i<n; i++) {
        	scanf("%d", &s[i]);
		printf(" %d ",s[i]);
    	}
    	printf("\n is %d realizable : %d\n", k, r=subset_sum(s,n,k));
    	if (r) report_subset(n,k);
    	printf("\n\n");
    }
    return 0;
}

/*    sudoku.c
      A Backtracking Program to solve Sudoku
*/

/* Copyright 2021 by Hiren S. Sharma; all rights reserved.
Permission is granted for use in non-commerical applications
provided this copyright notice remains intact and unchanged.
*/


#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#define BASED       3                     /* base dimension, 3*3 blocks */
#define DIMENSION   9                     /* 9*9 board */
#define NCELLS      DIMENSION*DIMENSION   /* 81 cells in 9-by-9-board */
#define MAXCANDIDATES   DIMENSION+1       /* max digit choices per cell */
bool finished = false;
typedef struct {
    int x, y;     /* row and column coordinates of square */
} point;
typedef struct {
   int m[DIMENSION+1][DIMENSION+1];    /* board contents */
   int freecount;                      /* open square count */
   point move[NCELLS+1];               /* which cells have we filled ? */
} boardtype;
extern bool finished;    /* solution found, stop search */
int steps;               /* how many total move insertions? */
bool fast;               /* fast or slow nextmove algorithm? */
bool smart;              /* quickly test for unfillable squares? */
void possible_values(point p, boardtype *board, bool possible[]) {
    int x, y;          /* square to fill */
    int i, j;          /* counters */
    int xlow, ylow;    /* origin of box with (x,y) */
    bool init;         /* is anything/everthing possible? */
    x = p.x;
    y = p.y;
    if ((board->m[x][y] != 0) || ((x < 0) || (y < 0))) {
        init = false;
    } else {
        init = true;
    }
    for (i = 1; i <= DIMENSION; i++) {
        possible[i] = init;
    }
    for (i = 0; i < DIMENSION; i++) {
        if (board->m[x][i] != 0) {
            possible[board->m[x][i]] = false;
        }
    }
    for (i = 0; i < DIMENSION; i++) {
        if (board->m[i][y] != 0) {
            possible[board->m[i][y]] = false;
        }
    }
    xlow = BASED * ((int) (x / BASED));
    ylow = BASED * ((int) (y / BASED));
    for (i = xlow; i < xlow + BASED; i++) {
        for (j = ylow; j < ylow + BASED; j++) {
            if (board->m[i][j] != 0) {
                possible[board->m[i][j]] = false;
            }
        }
    }
}
void print_possible(bool possible[]) {
    int i;    /* counter */
    for (i = 0; i <= DIMENSION; i++) {
        if (possible[i]) {
            printf(" %d", i);
        }
        printf("\n");
    }
}
int possible_count(int x, int y, boardtype *board) {
    int i;                      /* counter */
    int cnt;                    /* number of open squares */
    bool possible[DIMENSION+1]; /* what is possible for the square */
    point p;
    p.x = x;
    p.y = y;
    possible_values(p, board, possible);
    cnt = 0;
    for (i = 0; i <= DIMENSION; i++) {
        if (possible[i]) {
            cnt++;
        }
    }
    return(cnt);
}
void fill_square(point p, int v, boardtype *board) {
    if (board->m[p.x][p.y] == 0) {
        board->freecount = board->freecount - 1;
    } else {
        printf("Warning : Already Filled Square (%d,%d)\n", p.x, p.y);
    }
    board->m[p.x][p.y] = v;
}
void free_square(point p, boardtype *board) {
    if (board->m[p.x][p.y] != 0) {
        board->freecount = board->freecount + 1;
    } else {
        printf("Warning : Already Empty Square (%d,%d)\n", p.x, p.y);
    }
    board->m[p.x][p.y] = 0;
}
void next_square(point *p, boardtype* board) {
    int i, j;               /* counters */
    int bestcnt, newcnt;    /* the best and latest square counts */
    bool doomed;            /* some empty square without moves? */
    bestcnt = DIMENSION + 1;
    doomed = false;
    p->x = p->y = -1;
    for (i = 0; i < DIMENSION; i++) {
        for (j = 0; j < DIMENSION; j++) {
            newcnt = possible_count(i, j, board);
            if ((newcnt == 0) && (board->m[i][j] == 0)) {
                doomed = true;
            }
            if (fast) {
                if ((newcnt < bestcnt) && (newcnt >= 1)) {
                    bestcnt = newcnt;
                    p->x = i;
                    p->y = j;
                }
            }
            else {  
                if ((newcnt >= 1) && (board->m[i][j] == 0)) {
                    p->x = i;
                    p->y = j;
                }
            }
        }
    }
    if (doomed && smart) {
        p->x = p->y = -1;    /* initialize to non-position */
    }
}
void print_board(boardtype *board) {
    int i, j;    /* counters */
    printf("\n There are %d free board positions\n", board->freecount);
    for (i = 0; i < DIMENSION; i++) {
        for (j = 0; j < DIMENSION; j++) {
            if (board->m[i][j] == 0) {
                printf(" ");
            } else {
                printf("%c", (char) '0' + board->m[i][j]);
            }
            if ((j + 1) % BASED == 0) {
                printf("|");
            }
        }
        printf("\n");
        if ((i + 1) % BASED == 0) {
            for (j = 0; j < (DIMENSION + BASED - 1); j++) {
                printf("-");
            }
            printf("\n");
        }
    }
}
void init_board(boardtype* board) {
    int i, j;    /* counters */
    for (i = 0; i < DIMENSION; i++) {
        for (j = 0; j < DIMENSION; j++) {
            board->m[i][j] = 0;
        }
        board->freecount = DIMENSION * DIMENSION;
    }
}
void read_board(boardtype* board) {
    int i, j;    /* counters */
    char c;
    int value;
    point p;
    init_board(board);
    for (i = 0; i < DIMENSION; i++) {
        for (j = 0; j < DIMENSION; j++) {
            scanf("%c", &c);
            value = (int) (c - '0');
            if (value != 0) {
                p.x = i;
                p.y = j;
                fill_square(p, value, board);
            }
        }
        scanf("\n"); /*newline*/
    }
}
void copy_board(boardtype *a, boardtype *b) {
    int i, j;
    b->freecount = a->freecount;
    for (i = 0; i < DIMENSION; i++) {
        for (j = 0; j < DIMENSION; j++) {
            b->m[i][j] = a->m[i][j];
        }
    }
}
void process_solution(int a[], int k, boardtype *board) {
    finished = true;
    printf("process solution\n");
    print_board(board);
}
bool is_a_solution(int a[], int k, boardtype *board) {
    steps = steps + 1;          /* count steps for results table */
    return (board->freecount == 0);
}
void make_move(int a[], int k, boardtype *board) {
    fill_square(board->move[k], a[k], board);
}
void unmake_move(int a[], int k, boardtype *board) {
    free_square(board->move[k], board);
}
void construct_candidates(int a[], int k, boardtype *board, int c[], int *nc) {
    int i;                       /* counter */
    bool possible[DIMENSION+1];  /* which digits fit in this square */
    next_square(&(board->move[k]), board);  /* pick square to fill next */
    *nc = 0;
    if ((board->move[k].x < 0) && (board->move[k].y < 0)) {
        return;    /* error condition, no moves possible */
    }
    possible_values(board->move[k], board, possible);
    for (i = 1; i <= DIMENSION; i++) {
        if (possible[i]) {
            c[*nc] = i;
            *nc = *nc + 1;
        }
    }
}
void backtrack(int a[], int k, boardtype *input) {
    int c[MAXCANDIDATES];           /* candidates for next position */
    int ncandidates;                /* next position candidate count */
    int i;                          /* counter */
    if (is_a_solution(a, k, input)) {
            process_solution(a, k, input);
    } else {
        k = k + 1;
        construct_candidates(a, k, input, c, &ncandidates);
        for (i = 0; i < ncandidates; i++) {
            a[k] = c[i];
            make_move(a, k, input);
            backtrack(a, k, input);
            unmake_move(a, k, input);
            if (finished) {
                return;    /* terminate early */
            }
        }
    }
}
void solve_problem(boardtype *board) {
   int a[DIMENSION * DIMENSION + 1];
   boardtype temp;
   steps = 0;
   copy_board(board, &temp);
   finished = false;
   backtrack(a,0, &temp);
   printf("It took %d steps to find solution ", steps);
   printf("for fast=%d  smart=%d\n", fast, smart);
}
int main(void) {
    boardtype board;              /* Sudoku board structure */
    read_board(&board);
    print_board(&board);
    fast = true;
    smart=true;
    solve_problem(&board);
    fast = true;
    smart=false;
    solve_problem(&board);
    fast = false;
    smart=true;
    solve_problem(&board);
    fast = false;
    smart=false;
    solve_problem(&board);
    return 0 ;
}