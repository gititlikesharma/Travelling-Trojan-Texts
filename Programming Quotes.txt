There are two ways of constructing a software design: One way is to make it so simple that there are obviously no deficiencies and the other way is to make it so complicated that there are no obvious deficiencies.

The computing scientist’s main challenge is not to get confused by the complexities of his own making.

The cheapest, fastest, and most reliable components are those that aren’t there.

One of my most productive days was throwing away 1000 lines of code.

When in doubt, use brute force.

Deleted code is debugged code.

Debugging is twice as hard as writing the code in the first place. 

The most effective debugging tool is still careful thought, coupled with judiciously placed print statements.

Controlling complexity is the essence of computer programming.

Beauty is more important in computing than anywhere else in technology because software is so complicated. Beauty is the ultimate defence against complexity.

UNIX was not designed to stop its users from doing stupid things, as that would also stop them from doing clever things.

If you’re willing to restrict the flexibility of your approach, you can almost always do something better.

And folks, let’s be honest. Sturgeon was an optimist. Way more than 90% of code is crap.

A data structure is just a stupid programming language.

The essence of XML is this: the problem it solves is not hard, and it does not solve the problem well.

A program that produces incorrect results twice as fast is infinitely slower.

Life is too short to run proprietary software.

I had a nightmare once in which I a had convinced a friend how wonderful C++ is. A while later he came back., and he was mad.[sic]

XML is like violence: if it doesn’t solve your problem, you aren’t using enough of it.

XML is like violence. Sure, it seems like a quick and easy solution at first, but then it spirals out of control into utter chaos.

Threads [and] signals [are] a platform-dependant trail of misery, despair, horror and madness.

Computers are about making life easier in much the same way that the Republican party is about fiscal responsibility and a culture of life.

All software sucks, be it open-source [or] proprietary. The only question is what can be done with particular instance of suckage, and that’s where having the source matters.

Mathematicians stand on each others' shoulders and computer scientists stand on each others' toes.

It’s not that Perl programmers are idiots, it’s that the language rewards idiotic behavior in a way that no other language or tool has ever done.

Out-of-band == should be on a separate channel…

It’s a curious thing about our industry: not only do we not learn from our mistakes, we also don’t learn from our successes.

Ethernet always wins.

The central enemy of reliability is complexity.

Simplicity is prerequisite for reliability.

Beware of “the real world”. A speaker’s apeal to it is always an invitation not to challenge his tacit assumptions.

Unix is a junk OS designed by a committee of PhDs.

i’ve wondered whether Linux sysfs should be called syphilis

A program is portable to the extent that it can be easily moved to a new computing environment with much less effort than would be required to write it afresh.

Programming graphics in X is like finding the square root of PI using Roman numerals.

Forward thinking was just the thing that made Multics what it is today.

The Eight Fallacies of Distributed Computing

The network is reliable
Latency is zero
Bandwidth is infinite
The network is secure
Topology doesn’t change
There is one administrator
Transport cost is zero
The network is homogeneous

To me perl is the triumph of utalitarianism.

RMS is to Unix, like Hitler [was] to Nietzsche.

Unix is simple. It just takes a genius to understand its simplicity.

Most XML i’ve seen makes me think i’m dyslexic. it also looks constipated, and two health problems in one standard is just too much.

PHP is a minor evil perpetrated and created by incompetent amateurs, whereas Perl is a great and insidious evil perpetrated by skilled but perverted professionals.

OAuth is the best that the wrong way of doing things can provide.

This ‘users are idiots, and are confused by functionality’ mentality of Gnome is a disease. If you think your users are idiots, only idiots will use it.

{Ex-Cyber} some part of me desperately wants to believe that XML-RPC is some kind of elaborate joke, like a cross between Discordianism and IP Over Avian Carriers

The only places for icons is in a church, a burning church at that.

The key to performance is elegance, not battalions of special cases.

Just because the standard provides a cliff in front of you, you are not necessarily required to jump off it.

Are you quite sure that all those bells and whistles, all those wonderful facilities of your so called powerful programming languages, belong to the solution set rather than the problem set?

Measuring programming progress by lines of code is like measuring aircraft building progress by weight.

The object-oriented model makes it easy to build up programs by accretion. What this often means, in practice, is that it provides a structured way to write spaghetti code.

First, solve the problem. Then, write the code.

Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves.

Correctness is clearly the prime quality. If a system does not do what it is supposed to do, then everything else about it matters little.

Complexity kills. It sucks the life out of developers, it makes products difficult to plan, build and test, it introduces security challenges and it causes end-user and administrator frustration.

If the designers of X Windows built cars, there would be no fewer than five steering wheels hidden about the cockpit, none of which followed the same principles – but you’d be able to shift gears with your car stereo. Useful feature that.

A language that doesn’t have everything is actually easier to program in than some that do.

Mostly, when you see programmers, they aren’t doing anything. One of the attractive things about programmers is that you cannot tell whether or not they are working simply by looking at them. Very often they’re sitting there seemingly drinking coffee and gossiping, or just staring into space. What the programmer is trying to do is get a handle on all the individual and unrelated ideas that are scampering around in his head.

Haskell is faster than C++, more concise than Perl, more regular than Python, more flexible than Ruby, more typeful than C#, more robust than Java, and has absolutely nothing in common with PHP.

You can’t trust code that you did not totally create yourself.

Object-oriented design is the roman numerals of computing.

Not only is UNIX dead, it’s starting to smell really bad.

We have persistant(sic) objects, they’re called files.

If you want to go somewhere, goto is the best way to get there.

The X server has to be the biggest program I’ve ever seen that doesn’t do anything for you.

A smart terminal is not a smartass terminal, but rather a terminal you can educate.

Simplicity is the ultimate sophistication.

Increasingly, people seem to misinterpret complexity as sophistication, which is baffling—the incomprehensible should cause suspicion rather than admiration. Possibly this trend results from a mistaken belief that using a somewhat mysterious device confers an aura of power on the user.

Compatibility means deliberately repeating other people’s mistakes.

[Like programmers] prostitutes also think they all suck.

And both, programmers and prostitutes, are right: they suck. The big difference is that prostitutes got the term “user-friendly” right.

The Purpose of Computing is Insight, Not Numbers.

Every methodology I’ve come across has, at its kernel, a very small section labelled “do magic here”.

I recommend the linux people to call it “GNU / Linux” instead of “GNU/Linux”. never hurts to distance yourself from GNU.

For the sinner deserves not life but death, according to the disk devices. For example, start with Plan 9, which is free of sin, the case is different from His perspective.

Trying to express implicit and fuzzy relationships in ways that are explicit and sharp doesn’t clarify the meaning, it destroys it.

Unix has retarded OS research by 10 years and linux has retarded it by 20.

Any program that tries to be so generalized and configurable that it could handle any kind of task will either fall short of this goal, or will be horribly broken.

Nobody who uses XML knows what they are doing.

Debugging time increases as a square of the program’s size.

I guess it’s like smart compiler for dumb people, and dumb compiler for smart people. But then smart compiler gets too smart.. so neither dumb nor smart people can understand it.

in aeronautical circles, it’s said that the f4 is proof that given enough thrust even a brick will fly.

linux is the f4 of computing?

It seems to me more like you use foresight and pessimism to avoid getting into situations where you need to demonstrate exceptional programming ability.

Comparing a computer language to a human language is like comparing an operating system kernel to a popcorn kernel.

Hofstadter’s Law: It always takes longer than you expect, even when you take into account Hofstadter’s Law.

My definition of an expert in any field is a person who knows enough about what’s really going on to be scared.

Every language has an optimization operator. In C++ that operator is ‘//’

Theory is when you know something, but it doesn’t work. Practice is when something works, but you don’t know why. Programmers combine theory and practice: Nothing works and they don’t know why.

A computer is a stupid machine with the ability to do incredibly smart things, while computer programmers are smart people with the ability to do incredibly stupid things. They are, in short, a perfect match

The best code is no code at all.

Before software can be reusable it first has to be usable.

This is one of the reasons Lisp doesn’t get anywhere. The trend to promote features so clever that you stop thinking about your problem and start thinking about the clever features. CL’s loop is so powerful that people invented functional programming so that they’d never have to use it.

More computing sins are committed in the name of efficiency (without necessarily achieving it) than for any other single reason - including blind stupidity.

There is not now, nor has there ever been, nor will there ever be, any programming language in which it is the least bit difficult to write bad code.

Program testing can be a very effective way to show the presence of bugs, but is hopelessly inadequate for showing their absence.

The competent programmer is fully aware of the limited size of his own skull. He therefore approaches his task with full humility, and avoids clever tricks like the plague.

Code never lies, comments sometimes do.

What I cannot build, I do not understand.

If we’d asked the customers what they wanted, they would have said “faster horses”

I am rarely happier than when spending an entire day programming my computer to perform automatically a task that would otherwise take me a good ten seconds to do by hand.

Programming is not a zero-sum game. Teaching something to a fellow programmer doesn’t take it away from you. I’m happy to share what I can, because I’m in it for the love of programming. The Ferraris are just gravy, honest!

I have found that the reason a lot of people are interested in artificial intelligence is the same reason a lot of people are interested in artificial limbs: they are missing one.

Once you’ve dressed and before you leave the house, look in the mirror and take at least one thing off.

When I am working on a problem I never think about beauty. I think only how to solve the problem. But when I have finished, if the solution is not beautiful, I know it is wrong.

I have always found that plans are useless, but planning is indispensable.

I will, in fact, claim that the difference between a bad programmer and a good one is whether he considers his code or his data structures more important. Bad programmers worry about the code. Good programmers worry about data structures and their relationships.

Software is like entropy. It is difficult to grasp, weighs nothing, and obeys the second law of thermodynamics; i.e. it always increases.

A fool with a tool is a more dangerous fool.

The best things are simple, but finding these simple things is not simple.

Some problems are so complex that you have to be highly intelligent and well informed just to be undecided about them.

The most amazing achievement of the computer software industry is its continuing cancellation of the steady and staggering gains made by the computer hardware industry.

Theory is when you know something, but it doesn’t work. Practice is when something works, but you don’t know why. Programmers combine theory and practice: Nothing works and they don’t know why.

Once a new technology starts rolling, if you’re not part of the steamroller, you’re part of the road.

Einstein argued that there must be simplified explanations of nature, because God is not capricious or arbitrary. No such faith comforts the software engineer.

The cost of adding a feature isn’t just the time it takes to code it. The cost also includes the addition of an obstacle to future expansion. … The trick is to pick the features that don’t fight each other.

With diligence it is possible to make anything run slowly.

Any intelligent fool can make things bigger, more complex, and more violent. It takes a touch of genius – and a lot of courage – to move in the opposite direction.

A foolish consistency is the hobgoblin of little minds, adored by little statesmen and philosophers and divines.

For a sucessful technology, honesty must take precedence over public relations for nature cannot be fooled.

Comparing to another activity is useful if it helps you formulate questions, it’s dangerous when you use it to justify answers.

Simplicity carried to the extreme becomes elegance.

Software obeys the law of gaseous expansion - it continues to grow until memory is completely filled.

The unavoidable price of reliability is simplicity.

The ability to simplify means to eliminate the unnecessary so that the necessary may speak.

Trying to outsmart a compiler defeats much of the purpose of using one.

You’re bound to be unhappy if you optimize everything.

A distributed system is one in which the failure of a computer you didn’t even know existed can render your own computer unusable.

But in our enthusiasm, we could not resist a radical overhaul of the system, in which all of its major weaknesses have been exposed, analyzed, and replaced with new weaknesses.

The proper use of comments is to compensate for our failure to express ourself in code.

If you want a product with certain characteristics, you must ensure that the team has those characteristics before the product’s development.

You can’t have great software without a great team, and most software teams behave like dysfunctional families.

Correctness is clearly the prime quality. If a system does not do what it is supposed to do, then everything else about it matters little.

Incorrect documentation is often worse than no documentation.

Software sucks because users demand it to.

Unformed people delight in the gaudy and in novelty. Cooked people delight in the ordinary.

There’s no sense being exact about something if you don’t even know what you’re talking about.

That’s the thing about people who think they hate computers. What they really hate is lousy programmers.

Search all the parks in all your cities; you’ll find no statues of committees.

Good code is short, simple, and symmetrical - the challenge is figuring out how to get there.

Fashion is something barbarous, for it produces innovation without reason and imitation without benefit.

Forgive him, for he believes that the customs of his tribe are the laws of nature!

The only sin is to make a choice without knowing you are making one.

It is a painful thing to look at your own trouble and know that you yourself and no one else has made it.

The primary duty of an exception handler is to get the error out of the lap of the programmer and into the surprised face of the user. Provided you keep this cardinal rule in mind, you can’t go far wrong.

A notation is important for what it leaves out.

An organisation that treats its programmers as morons will soon have programmers that are willing and able to act like morons only.

I have always wished that my computer would be as easy to use as my telephone. My wish has come true. I no longer know how to use my telephone.

The most important single aspect of software development is to be clear about what you are trying to build.

The best is the enemy of the good.

Software gets slower faster than hardware gets faster.

The purpose of software engineering is to control complexity, not to create it.

I object to doing things that computers can do.

Simplicity – the art of maximizing the amount of work not done – is essential.

When you want to do something differently from the rest of the world, it’s a good idea to look into whether the rest of the world knows something you don’t.

Perilous to us all are the devices of an art deeper than that which we possess ourselves.

Complexity has nothing to do with intelligence, simplicity does.

If it doesn’t work, it doesn’t matter how fast it doesn’t work.

Simplicity is hard to build, easy to use, and hard to charge for. Complexity is easy to build, hard to use, and easy to charge for.

They won’t tell you that they don’t understand it; they will happily invent their way through the gaps and obscurities.

In software, the most beautiful code, the most beautiful functions, and the most beautiful programs are sometimes not there at all.

Computers make it easier to do a lot of things, but most of the things they make it easier to do don’t need to be done.

True glory consists in doing what deserves to be written; in writing what deserves to be read.

The whole point of getting things done is knowing what to leave undone.

What is the difference between an object methodologist and a terrorist ? You can negotiate with the terrorist.

One Page Principle: A specification that will not fit on one page of 8.5x11 inch paper cannot be understood.

The whole HTML validation exercise is questionable, but validating as XHTML is flat-out masochism. Only recommended for those that enjoy pain. Or programmers. I can’t always tell the difference.

When in doubt, leave it out.

No code is faster than no code.

As a rule, software systems do not work well until they have been used, and have failed repeatedly, in real applications.

OOP is to writing a program, what going through airport security is to flying.

The problem with object-oriented languages is they’ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.

As a programmer, it is your job to put yourself out of business. What you do today can be automated tomorrow.

IDE features are language smells.

PHP is the Sarah Palin of programming languages.

A good way to have good ideas is by being unoriginal.

The comment about developers making work for themselves is also spot on. I answer a lot of programming questions, and the questions are always asked because the programmer has reached the end of a twisty maze of his own creation. Turn around, walk, spin around, and try again. You’ll find a better solution.

A program is like a poem: you cannot write a poem without writing it. Yet people talk about programming as if it were a production process and measure “programmer productivity"in terms of "number of lines of code produced”.In so doing they book that number on the wrong side of the ledger: We should always refer to"the number of lines of code spent".

‘Layered approach’ is not a magic incantation to excuse any bit of snake oil. Homeopathic remedies might not harm (pure water is pure water), but that’s not an excuse for quackery. And frankly, most of the ‘security improvement’ crowd sound exactly like woo-peddlers.

The trick is to fix the problem you have, rather than the problem you want.

Security is a state of mind.

Never attribute to funny hardware that which can be adequately explained by broken locking.

Things which any idiot could write usually have the quality of having been written by an idiot.

In programming the hard part isn’t solving problems, but deciding what problems to solve.

Do I really want to be using a language where memoize is a PhD-level topic?

People stop thinking and questioning [and] then its just worshipping some rules without any pruporse.

If you start programming by learning perl you will just become a menace to your self and others.

When there is no type hierarchy you don’t have to manage the type hierarchy.

Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary.

Software efficiency halves every 18 months, compensating Moore’s Law.

So-called “smart” software usually is the worst you can imagine.

Such is modern computing: everything simple is made too complicated because it’s easy to fiddle with; everything complicated stays complicated because it’s hard to fix.

It is not that uncommon for the cost of an abstraction to outweigh the benefit it delivers. Kill one today!

So much complexity in software comes from trying to make one thing do two things.

The standard rule is, when you’re in a hole, stop digging; that seems not to apply [to] software nowadays.

Languages that try to disallow idiocy become themselves idiotic.

A complex system that works is invariably found to have evolved from a simple system that worked. The inverse proposition also appears to be true: A complex system designed from scratch never works and cannot be made to work.

Design patterns are concepts used by people who can’t learn by any method except memorization, so in place of actual programming ability, they memorize “patterns” and throw each one in sequence at a problem until it works

One of the big lessons of a big project is you don’t want people that aren’t really programmers programming, you’ll suffer for it!

Premature optimization, that’s like a sneeze. Premature abstraction is like ebola; it makes my eyes bleed.

Premature optimizations can be troublesome to revert, but premature generalizations are often near impossible.

Premature optimization, that’s like a fart. Premature abstraction is like taking a dump on another developer’s desk.

Normal people believe that if it ain’t broke, don’t fix it. Engineers believe that if it ain’t broke, it doesn’t have enough features yet.

If you give someone a program, you will frustrate them for a day; if you teach them how to program, you will frustrate them for a lifetime.

pi seconds is a nanocentury.

Regression testing cuts test intervals in half.

Absence makes the heart grow fonder.

Out of sight, out of mind.

Plagiarism is the sincerest form of flattery.

When in doubt, use brute force.

Allocate four digits for the year part of a date: a new millennium is approaching.

Avoid asymmetry.

The sooner you start to code, the longer the program will take.

If you can't write it down in English, you can't code it.

If the code and the comments disagree, then both are probably wrong.

If you have too many special cases, you are doing it wrong.

Get your data structures correct first, and the rest of the program will write itself.

Make a user interface as consistent and as predictable as possible.

A program designed for inputs from people is usually stressed beyond breaking point by computer-generated inputs.

Twenty percent of all input forms filled by people contain bad data.

Eighty percent of all input forms ask questions they have no business asking.

Don't make the user interface provide information that the system already knows.

For 80% of all data sets, 95% of the information can be seen in a good graph.

Of all my programming bugs, 80% are syntax errors. Of the remaining 20%, 80% are trivial logical errors. Of the remaining 4%, 80% are pointer errors. And the remaining 0.8% are hard.

Don't debug standing up. It cuts your patience in half, and you need all you can muster.

Don't get suckered in by the comments---they can be terribly misleading. Debug only code.

Testing can show the presence of bugs, not their absence.

Each new user of a new system uncovers a new class of bugs.

If it ain't broke, don't fix it.

If we can't fix it, it ain't broke.

The first step in fixing a broken program is getting it to fail repeatably.

[The First Rule of Program Optimization] Don't do it.

[The Second Rule of Program Optimization---For experts only] Don't do it yet.

The fastest algorithm can frequently be replaced by one that is almost as fast and much easier to understand.

One some machines indirection is slower with displacement, so the most-used member of a structure or a record should be first.

In non-I/O-bound programs, less than four percent of a program generally accounts for more than half of its running time.

Before optimizing, use a profiler to locate the "hot spots" of the program.

When you turn an ordinary page of code into just a handful of instructions for speed, expand the comments to keep the number of source lines constant.

If the programmer can simulate a construct faster than a compiler can implement the construct itself, then the compiler writer has blown it badly.

To speed up an I/O-bound program, begin by accounting for all I/O. Eliminate that which is unnecessary or redundant, and make the remaining as fast as possible.

The fastest I/O is no I/O.

The cheapest, fastest and most reliable components of a computer system are those that aren't there.

Most assembly languages have a loop operation that does a compare and branch in a single machine instruction; although it was intended for loops, it can sometimes be used to do a general comparison very efficiently.

Making a wrong program worse is no sin.

Electricity travels a foot in a nanosecond.

Lisp programmers know the value of everything and the cost of nothing.

Don't include a sentence in documentation if its negation is obviously false.

When explaining a command, or language feature, or hardware widget, first describe the problem it is designed to solve.

[One Page Principle] A {specification, design, procedure, test plan} that will not fit on one page of 8.5-by-11 inch paper cannot be understood.

The job's not over until the paperwork's done.

The structure of a system reflects the structure of the organization that built it.

Don't keep doing what doesn't work.

[Rule of Credibility] The first 90% of the code accounts for the first 90% of the development time. The remaining 10% of the code accounts for the other 90% of the development time.

Less than 10% of the code has to do with the ostensible purpose of the system; the rest deals with input-output, data validation, data structure maintenance, and other housekeeping.

Good judgement comes from experience, and experience comes from bad judgement.

Don't write a new program if one already does more or less what you want. And if you must write a program, use existing code to do as much of the work as possible.

Whenever possible, steal code.

Good customer relations double productivity.

Translating a working program to a new language or system takes ten percent of the original development time or manpower or cost.

Don't use the computer to do things that can be efficiently done by hand.

Don't use hands to do things that can be efficiently done by the computer.

I would rather write programs to help me write programs than write programs.

Plan to throw one away, you will anyhow.

If you plan to throw one away, you will throw away two.

Prototyping cuts the work to produce a system by 40%.

[Thompson's Rule for First-Time Telescope Makers] It is faster to make a four-inch mirror and then a six-inch mirror than to make a six-inch mirror.

Furious activity is no substitute for understanding.

Always do the hard part first. If the hard part is impossible, why waste time on the easy part? Once the hard part is done, you're home free.

Always do the east part first. What you think at first is the easy part often turns out to be the hard part. Once the easy part is done, you can concentrate all your efforts on the hard part.

[Sturgeon's Law---This applies as well to computer science as to science fiction] Sure, 90% of all software is crap. That's because 90% of everything is crap.

If you lie to the computer, it will get you.

If a system doesn't have to be reliable, it can do anything else.

One person's constant is another person's variable.

One person's data is another person's program.

[KISS] Keep it simple, stupid.

If something can go wrong, it will.

Adding manpower to a late software project makes it later.

Any piece of software reflects the organizational structure that produced it.

Be conservative in what you send, be liberal in what you accept.

For many phenomena, 80% of consequences stem from 20% of the causes.

In a hierarchy, every employee tends to rise to his level of incompetence.

In cryptography, a system should be secure even if everything about the system, except for a small piece of information - the key - is public knowledge.

Given enough eyeballs, all bugs are shallow.

The power of computers per unit cost doubles every 24 month.

The number of transistors on an integrated circuit will double in about 18 months.

The processing speed of computers will double every two years.

Software gets slower faster than hardware gets faster.

The first 90% of the code takes 10% of the time. The remaining 10% takes the other 90% of the time.

Premature optimization is the root of all evil.

Any technology that surpasses 50% penetration will never double again in any number of months.

One man's constant is another man's variable.

Functions delay binding, data structures induce binding. 

Syntactic sugar causes cancer of the semi-colons.

Every program is a part of some other program and rarely fits.

If a program manipulates a large amount of data, it does so in a small number of ways.

Symmetry is a complexity reducing concept; seek it everywhere.

It is easier to write an incorrect program than understand a correct one.

A programming language is low level when its programs require attention to the irrelevant.

It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures.

If you have a procedure with 10 parameters, you probably missed some.

Recursion is the root of computation since it trades description for time.

Everything should be built top-down, except the first time.

Every program has at least two purposes: the one for which it was written and another for which it wasn't.

If a listener nods his head when you're explaining your program, wake him up.

A program without a loop and a structured variable isn't worth writing.

A language that doesn't affect the way you think about programming, is not worth knowing.

Wherever there is modularity there is the potential for misunderstanding.

Hiding information implies a need to check communication.

Optimization hinders evolution.

A good system can't have a weak command language.

To understand a program you must become both the machine and the program.

Perhaps if we wrote programs from childhood on, as adults we'd be able to read them.

Once you understand how to write a program get someone else to write it.

In programming, everything we do is a special case of something more general and often we know it too quickly.

Simplicity does not precede complexity, but follows it.

Programmers are not to be measured by their ingenuity and their logic, but by the completeness of their case analysis. 

The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.

The most important computer is the one that rages in our skulls and ever seeks that satisfactory external emulator.

Structured Programming supports the law of the excluded muddle.

Re graphics: A picture is worth 10K words - but only those to describe the picture.

There are two ways to write error-free programs; only the third one works.

Some programming languages manage to absorb change, but withstand progress.

You can measure a programmer's perspective by noting his attitude on the continuing vitality of FORTRAN.

In software systems it is often the early bird that makes the worm.

Sometimes I think the only universal in the computing field is the fetch-execute cycle.

The goal of computation is the emulation of our synthetic abilities,not the understanding of our analytic ones.

Like punning, programming is a play on words.

There is no such thing as a free variable.

When we understand knowledge-based systems, it will be as before except our finger-tips will have been singed.

Bringing computers into the home won't change either one, but may revitalize the corner saloon. 

Systems have sub-systems and sub-systems have subsystems and so on.

So many good ideas are never heard from again once they embark in a voyage on the semantic gulf.

Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.

A LISP programmer knows the value of everything, but the cost of nothing.

Software is under a constant tension. Being symbolic it is arbitrarily perfectible; but also it is arbitrarily changeable.

It is easier to change the specification to fit the program than vice versa.

Fools ignore complexity. Pragmatists suffer it. Optimists can avoid it. Geniuses remove it.

In English every word can be verbed. Would that it were so in our programming languages.

In programming, as in everything else, to be in error is to be reborn.

In computing, invariants are ephemeral.

When we write programs that "learn", it turns out we do and they don't.

Goals advance technique and technique survives even when goal structures crumble.

Computers process numbers - not symbols.

Making something variable is easy. Controlling duration of constancy is the trick.

Think of all the psychic energy expended in seeking a fundamental distinction between "algorithm" and "program".

If we believe in data structures, we must believe in independent processing.

In a 5 year period we get one superb programming language. Only we can't control when the 5 year period will begin. 

Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.

An adequate bootstrap is a contradiction in terms.

It is not a language's weaknesses but its strengths that control the gradient of its change.

Is it possible that software is not like anything else, that it is meant to be discarded that the whole point is to always see it as soap bubble ?

It is the user who should parametrize procedures, not their creators.

The cybernetic exchange between man, computer and algorithm is like a game of musical chairs, the frantic search for balance always leaves one of the three standing.

If your computer speaks English it was probably made in Japan.

A year spent in artificial intelligence is enough to make one believe in God.

Prolonged contact with the computer turns mathematicians into clerks and vice versa.

In computing, turning the obvious into the useful is a living definition of the word "frustration".

What we work on today, others will first think of tomorrow.

It is not the computer's fault that Maxwell's equations are not adequate to design the electric motor.

One does not learn computing by using a hand calculator but one can forget arithmetic.

Computation has made the tree flower.

The computer is the ultimate polluter: Its feces are indistinguishable from the food it produces.

When someone says "I want a programming language in which I need only say what I wish done," give him a lollipop.

Interfaces keep things tidy, but don't accelerate growth: Functions do.

Don't have good ideas if you aren't willing to be responsible for them.

Computers don't introduce order anywhere as much as they expose opportunities.

When a professor insists computer science is X but not Y, have compassion for his graduate students.

In computing, the mean time to failure keeps getting shorter.

In man-machine symbiosis, it is man who must adjust: The machines can't.

We will never run out of things to program as long as there is a single program around.

Dealing with failure is easy: Work hard to improve. Success is also easy to handle: You've solved the wrong problem. Work hard to improve.

One can't proceed from the informal to the formal by formal means.

Purely applicative languages are poorly applicable.

The proof of a system's value is its existence.

You can't communicate complexity, only an awareness of it.

It's difficult to extract sense from strings, but they're the only communication coin we can count on.

Whenever two programmers meet to criticize their programs, both are silent. 

Editing is a rewording activity.

Within a computer natural language is unnatural.

Most people find the concept of programming obvious, but the doing impossible.

You think you know when you learn,are more sure when you can write,even more when you can teach,but certain when you can program.

Programming is an unnatural act.

Adapting old programs to fit new machines usually means adapting new machines to behave like old ones.

In seeking the unattainable, simplicity only gets in the way.