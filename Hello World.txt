									Hello World in 800+ Programming Languages 

0815
<:48:x<:65:=<:6C:$=$=$$~<:03:+
$~<:ffffffffffffffb1:+$<:77:~$
~<:fffffffffffff8:x+$~<:03:+$~
<:06:x-$x<:0e:x-$=x<:43:x-$
  
11l
print(‘Hello world!’)

360 Assembly
HELLO    CSECT 
         USING HELLO,15
         LA    1,MSGAREA     Point Register 1 to message area
         SVC   35            Invoke SVC 35 (Write to Operator) 
         BR    14            Return
MSGAREA  EQU   *             Message Area
         DC    AL2(19)       Total area length = 19 (Prefix length:4 + Data Length:15) 
         DC    XL2'00'       2 bytes binary of zeros
         DC    C'Hello world!'  Text to be written to system console
         END
         WTO   'Hello world!'
         BR    14            Return
         END
 
4DOS Batch
echo Hello world!

6502 Assembly
; goodbyeworld.s for C= 8-bit machines, ca65 assembler format.
; String printing limited to strings of 256 characters or less.
 
a_cr	= $0d		; Carriage return.
bsout	= $ffd2		; C64 KERNEL ROM, output a character to current device.
			; use $fded for Apple 2, $ffe3 (ascii) or $ffee (raw) for BBC.
	.code
 
	ldx #0		; Starting index 0 in X register.
printnext:
	lda text,x	; Get character from string.
	beq done	; If we read a 0 we're done.
	jsr bsout	; Output character. 
	inx		; Increment index to next character.
	bne printnext	; Repeat if index doesn't overflow to 0.
done:
	rts		; Return from subroutine.
 
	.rodata
 
text:
	.byte	"Hello world!", a_cr, 0

6800 Assembly
        .cr  6800
        .tf  gbye6800.obj,AP1
        .lf  gbye6800
;=====================================================;
;        Hello world! for the Motorola 6800        ;
;                 by barrym 2013-03-17                ;
;-----------------------------------------------------;
; Prints the message "Hello world!" to an ascii    ;
;   terminal (console) connected to a 1970s vintage   ;
;   SWTPC 6800 system, which is the target device for ;
;   this assembly.                                    ;
; Many thanks to:                                     ;
;   swtpc.com for hosting Michael Holley's documents! ;
;   sbprojects.com for a very nice assembler!         ;
;   swtpcemu.com for a very capable emulator!         ;
; reg x is the string pointer                         ;
; reg a holds the ascii char to be output             ;
;-----------------------------------------------------;
outeee   =   $e1d1      ;ROM: console putchar routine
        .or  $0f00
;-----------------------------------------------------;
main    ldx  #string    ;Point to the string
        bra  puts       ;  and print it
outs    jsr  outeee     ;Emit a as ascii
        inx             ;Advance the string pointer
puts    ldaa ,x         ;Load a string character
        bne  outs       ;Print it if non-null
        swi             ;  else return to the monitor
;=====================================================;
string  .as  "Hello world!",#13,#10,#0
        .en

8080 Assembly
	; This is Hello World, written in 8080 assembly to run under CP/M
	; As you can see, it is similar to the 8086, and CP/M is very
	; similar to DOS in the way it is called.
	org	100h	; CP/M .COM entry point is 100h - like DOS
	mvi	c,9	; C holds the syscall, 9 = print string - like DOS
	lxi	d,msg	; DE holds a pointer to the string
	jmp	5	; CP/M calls are accessed through the jump at 05h
	; Normally you'd CALL it, but since you'd end the program by RETurning,
	; JMP saves a byte (if you've only got 64k of address space you want to
	; save bytes). 
msg:	db	'Hello world!$'

8086 Assembly
DOSSEG
.MODEL TINY
.DATA
TXT DB "Hello world!$"
.CODE
START:
	MOV ax, @DATA
	MOV ds, ax
 
	MOV ah, 09h		; prepare output function
	MOV dx, OFFSET TXT	; set offset
	INT 21h			; output string TXT
 
	MOV AX, 4C00h 		; go back to DOS
	INT 21h
END START

8th
"Hello world!\n" . bye

AArch64 Assembly
.equ STDOUT, 1
.equ SVC_WRITE, 64
.equ SVC_EXIT, 93
 
.text
.global _start
 
_start:
	stp x29, x30, [sp, -16]!
	mov x0, #STDOUT
	ldr x1, =msg
	mov x2, 13
	mov x8, #SVC_WRITE
	mov x29, sp
	svc #0 // write(stdout, msg, 13);
	ldp x29, x30, [sp], 16
	mov x0, #0
	mov x8, #SVC_EXIT
	svc #0 // exit(0);
 
msg:	.ascii "Hello World!\n"
.align 4

ABAP
REPORT zgoodbyeworld.
  WRITE 'Hello world!'.

ACL2
(cw "Hello world!~%")

ActionScript
trace("Hello world!");

Ada
with Ada.Text_IO; use Ada.Text_IO;
procedure Main is
begin
  Put_Line ("Hello world!");
end Main;

Agena
print( "Hello world!" )

Aime
integer
main(void)
{
    o_text("Hello world!\n");
 
    return 0;
}

Algae
printf("Hello world!\n");

ALGOL 60
'BEGIN'
    OUTSTRING(1,'('Hello world!')');
    SYSACT(1,14,1)
'END'

ALGOL 68
main: (
  printf($"Hello world!"l$)
)

ALGOL W
begin
    write( "Hello world!" )
end.

ALGOL-M
BEGIN
    WRITE( "Hello world!" );
END

Alore
Print('Hello world!')

AmbientTalk
system.println("Hello world!")

AmigaE
PROC main()
  WriteF('Hello world!\n')
ENDPROC

AntLang
echo["Hello, World!"]

Anyways
There was a guy called Hello World
"Ow!" it said.
That's all folks!

APL
'Hello world!'

AppleScript
"Hello world!"
log "Hello world!"

Applesoft BASIC
PRINT "Hello world!"

Apricot
(puts "Hello world!")

Arc
(prn "Hello world!")

Arendelle
"Hello world!"

Argile
use std
print "Hello world!"

ARM Assembly
.global main
 
message:
    .asciz "Hello world!\n"
    .align 4
 
main:
    ldr r0, =message
    bl printf
 
    mov r7, #1
    swi 0

ArnoldC
IT'S SHOWTIME
TALK TO THE HAND "Hello world!"
YOU HAVE BEEN TERMINATED

Arturo
print "Hello world!"

AsciiDots
.-$'Hello, World!'
 
Astro
print "Hello world!"

Asymptote
write('Hello world!');

ATS
implement main0 () = print "Hello world!\n"

AutoHotkey
DllCall("AllocConsole")
FileAppend, Goodbye`, World!, CONOUT$
FileReadLine, _, CONIN$, 1
DllCall("AttachConsole", "int", -1)
FileAppend, Goodbye`, World!, CONOUT$
SendInput Hello world!{!}

AutoIt
ConsoleWrite("Hello world!" & @CRLF)

AutoLISP
(printc "Hello World!")

Avail
Print: "Hello World!";

AWK
BEGIN{print "Hello world!"}

Axe
Disp "Hello world!",i

B
main()
{
    putstr("Hello world!*n");
    return(0);
}

B4X
Log("Hello world!")

Babel
"Hello world!" <<

bash
echo "Hello world!"
BASIC
10 PRINT "Hello world!"
PRINT "Hello world!"

BASIC256
PRINT "Hello world!"

Batch File
echo Hello world!
setlocal enableDelayedExpansion
echo Hello world!^^!

Battlestar
const hello = "Hello world!\n"
print(hello)

BBC BASIC
      PRINT "Hello world!"

bc
"Hello world!
"

BCPL
GET "libhdr"
 
LET start() = VALOF
{ writef("Hello world!")
  RESULTIS 0
}

beeswax
*`Hello, World!

Befunge
52*"!dlroW ,eybdooG">:#,_@

Bird
use Console
 
define Main
    Console.Println "Hello world"
end

Blast
# This will display a goodbye message on the terminal screen
.begin
display "Hello world!"
return
# This is the end of the script.

blz
print("Hello world!")

BML
display "Hello world!"

Boo
print "Hello world!"

bootBASIC
10 print "Hello world!"

BQN
•Out "Hello world!"

Brace
#!/usr/bin/env bx
use b
Main:
	say("Hello world!")

Bracmat
put$"Hello world!"

Brainf***
++++++++++[>+>+++>++++>+++++++>++++++++>+++++++++>++
++++++++>+++++++++++>++++++++++++<<<<<<<<<-]>>>>+.>>>
>+..<.<++++++++.>>>+.<<+.<<<<++++.<++.>>>+++++++.>>>.+++.
<+++++++.--------.<<<<<+.<+++.---.

Brat
p "Hello world!"

Brlcad
echo Hello world!
 
Burlesque
"Hello world!"sh

C
#include <stdlib.h>
#include <stdio.h> 
int main(void)
{
  printf("Hello world!\n");
  return EXIT_SUCCESS;
}

Or -
#include <stdlib.h>
#include <stdio.h>
int main(void)
{
  puts("Hello world!");
  return EXIT_SUCCESS;
}

Or -
#include<stdio.h>
int main()
{
  printf("\nHello world!");
  return 0;
}

Or - 
#include<stdio.h>
int main()
{
	return printf("\nHello World!");
}
 
C#
namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            System.Console.WriteLine("Hello world!");
        }
    }
}

C++
#include <iostream>
int main () {
  std::cout << "Hello world!" << std::endl;
}

C++/CLI
using namespace System;
int main()
{
  Console::WriteLine("Hello world!");
}

C1R
Hello_world/Text

C2
module hello_world;
import stdio as io;
 
func i32 main(i32 argc, char** argv) {
    io.printf("Hello World!\n");
    return 0;
}

C3
import std::io;
func int main() 
{
    io::println("Hello, World!");
    return 0;
}

Casio BASIC
Locate 1,1,"Hello World!"

Cat
"Hello world!" writeln

Cduce
print "Hello world!";;

Chapel
writeln("Hello world!");

Chef
Goodbye World Souffle.
 
Ingredients.
71 g green beans
111 cups oil
98 g butter
121 ml yogurt
101 eggs
44 g wheat flour
32 zucchinis
119 ml water
114 g red salmon
108 g lard
100 g dijon mustard
33 potatoes
 
Method.
Put potatoes into the mixing bowl.
Put dijon mustard into the mixing bowl.
Put lard into the mixing bowl.
Put red salmon into the mixing bowl.
Put oil into the mixing bowl.
Put water into the mixing bowl.
Put zucchinis into the mixing bowl.
Put wheat flour into the mixing bowl.
Put eggs into the mixing bowl.
Put yogurt into the mixing bowl.
Put butter into the mixing bowl.
Put dijon mustard into the mixing bowl.
Put oil into the mixing bowl.
Put oil into the mixing bowl.
Put green beans into the mixing bowl.
Liquefy contents of the mixing bowl.
Pour contents of the mixing bowl into the baking dish.
 
Serves 1.

ChucK
<<< "Hello world!">>>;

Cind
 
execute() {
    host.println("Hello world!");
}
 
Clay
main() {
    println("Hello world!");
}

Clean
Start = "Hello world!"

Clio
'hello world!' -> print

Clipper
? "Hello world!"

CLIPS
(printout t "Hello world!" crlf)

Clojure
(println "Hello world!")

CMake
message(STATUS "Hello world!")

COBOL
	program-id. hello.
	procedure division.
		display "Hello world!".
		stop run.

Cobra
class Hello
    def main
        print 'Hello world!'

CoffeeScript
console.log "Hello world!"
print "Hello world!"

ColdFusion
<cfoutput>Hello world!</cfoutput>

Comal
PRINT "Hello world!"

Comefrom0x10
'Hello world!'
"Hello world!"

Commodore BASIC
10 print chr$(147);chr$(14);:REM 147=clear screen, 14=switch to lowercase mode
20 print "Hello world!"
30 end

Common Lisp
(format t "Hello world!~%")

Component Pascal
 
MODULE Hello;
	IMPORT Out;
 
	PROCEDURE Do*;
	BEGIN
		Out.String("Hello world!"); Out.Ln
	END Do;
END Hello.

Coq
 
Require Import Coq.Strings.String.
 
Eval compute in ("Hello world!"%string).
 
Corescript
print Hello world!

Cowgol
include "cowgol.coh";
print("Hello world!");
print_nl();

Crack
import crack.io cout;
cout `Hello world!\n`;
 
Creative Basic 
OPENCONSOLE
 
PRINT"Hello world!"
 
'This line could be left out.
PRINT:PRINT:PRINT"Press any key to end."
 
'Keep the console from closing right away so the text can be read.
DO:UNTIL INKEY$<>""
 
CLOSECONSOLE
 
END
 
Crystal
puts "Hello world!"

D
import std.stdio;
void main() {
    writeln("Hello world!");
}

Dafny
method Main() {
  print "hello, world!\n";
  assert 10 < 2;
}
 
Dao
io.writeln( 'Hello world!' )

Dart
main() {
    var bye = 'Hello world!';
    print("$bye");
}

DataWeave
"Hello world!"

DBL
;
;       Hello world for DBL version 4 by Dario B.
;
                                PROC
;------------------------------------------------------------------
        XCALL FLAGS (0007000000,1)           ;Suppress STOP message
 
        OPEN (1,O,'TT:')
        WRITES (1,"Hello world")
 
        DISPLAY (1,"Hello world",10)
        DISPLAY (1,$SCR_MOV(-1,12),"again",10)  ;move up, right and print
 
        CLOSE 1
END

Dc
[Hello world!]p

DCL
$ write sys$output "Hello world!"

DDNC
0 111 10
0 15 11
0 15 12
0 31 13
0 47 14
0 59 15
0 125 16
0 3 17
0 0 18
0 63 19
0 15 20
0 12 21
0 36 22
0 31 23
0 17 24
 
0 500 3
0 10 2
0 15 5
 
60 4
2 2 1
80 1
72 3
30 2
31 5
62 5
61 4
64
 
Delphi
program ProjectGoodbye;
{$APPTYPE CONSOLE}
begin
  WriteLn('Hello world!');
end.
 
DeviousYarn
o:"Hello world!

DIBOL-11
 
          START     ;Hello World
 
          RECORD  HELLO
,         A11, 'Hello World'
 
          PROC
          XCALL FLAGS (0007000000,1)          ;Suppress STOP message
 
          OPEN(8,O,'TT:')
          WRITES(8,HELLO)
          END
 
 
DIV Games Studio
PROGRAM HELLOWORLD;
 
BEGIN
 
    WRITE_TEXT(0,160,100,4,"HELLO WORLD!");
    LOOP
        FRAME;
    END
END
 
 
DM
/client/New()
    ..()
    src << "Hello world!"
 
Dragon
showln "Hello world!"
 
DWScript
PrintLn('Hello world!');
 
Dyalect
print("Hello world!")

Dylan
module: hello-world
 
format-out("%s\n", "Hello world!");
 
Dylan.NET
import System
 
assembly helloworld exe
ver 1.2.0.0
 
class public Program
 
   method public static void main()
      Console::WriteLine("Hello world!")
   end method
 
end class
 
Déjà Vu
!print "Hello world!"

E
println("Hello world!")
 
stdout.println("Hello world!")

EasyLang
print "Hello world!"

eC
class GoodByeApp : Application
{
   void Main()
   {
      PrintLn("Hello world!");
   }
}

EchoLisp
(display "Hello world!" "color:blue")
 
ECL
OUTPUT('Hello world!');
 
EDSAC order code
[ Print HELLO WORLD ]
[ A program for the EDSAC ]
[ Works with Initial Orders 2 ]
 
T64K  [ Set load point: address 64 ]
GK    [ Set base address ]
O13@  [ Each O order outputs one ]
O14@  [ character. The numerical ]
O15@  [ parameter gives the offset ]
O16@  [ (from the base address) where ]
O17@  [ the character to print is ]
O18@  [ stored ]
O19@
O20@
O21@  
O22@
O23@
O24@
ZF    [ Stop ]
*F    [ Shift to print letters ]
HF    [ Character literals ]
EF
LF
LF
OF
!F    [ Space character ]
WF
OF
RF
LF
DF
EZPF  [ Start program beginning at
        the load point ]

Efene
@public 
run = fn () {
    io.format("Hello world!~n")
}

Egel
def main = "Hello World!"
 
Egison
(define $main
  (lambda [$argv]
    (write-string "Hello world!\n")))
 
EGL
program HelloWorld
    function main()
        SysLib.writeStdout("Hello world!");
    end
end
 
Eiffel
class
    HELLO_WORLD
create
    make
feature
    make
        do
            print ("Hello world!%N")
        end
end

Ela
open monad io
do putStrLn "Hello world!" ::: IO

elastiC
package hello;
 
    // Import the `basic' package
    import basic;
 
    // Define a simple function
    function hello()
    {
        // Print hello world
        basic.print( "Hello world!\n" );
    }
 
    /*
     *  Here we start to execute package code
     */
 
    // Invoke the `hello' function
    hello();

Elena
public program()
{
    console.writeLine:"Hello world!"
}

Elisa
 "Hello world!"? 

Elixir
IO.puts "Hello world!"
 
Elm
main = text "Goodbye World!"

Emacs Lisp
(insert "Hello world!")

Emojicode
🏁 🍇
  😀 🔤Hello world!🔤
🍉

Erlang
io:format("Hello world!~n").

ERRE
! Hello World in ERRE language
PROGRAM HELLO
BEGIN
  PRINT("Hello world!")
END PROGRAM
 
Euler Math Toolbox
"Hello world!"

Extended BrainF***
[.>]@Hello world!

Ezhil
பதிப்பி"வணக்கம் உலகம்!"
பதிப்பி "Hello world!"
பதிப்பி"******* வணக்கம்! மீண்டும் சந்திப்போம் *******"
exit()

F#
printfn "%s" "Hello world!"

Factor
"Hello world!" print

Falcon
printl("Hello world!")
> "Hello world!"

FALSE
"Hello world!
"

Fantom 
class HelloText
{
  public static Void main ()
  {
    echo ("Hello world!")
  }
}
 
Fennel
(print "Hello World")

ferite
uses "console";
Console.println( "Goodby, World!" );

Fermat
[message]:='Hello world!'
!([message:char)

Fexl
say "Hello world!"

Fhidwfe
puts$ "Hello, world!\n"

Fish
!v"Hello world!"r!
 >l?!;o

FOCAL
TYPE "Hello, world" !

Forth
: goodbye ( -- )   ." Hello world!" CR ;

Fortran
print *,"Hello world!"

Fortress
export Executable                                                                                                                       
 
run() = println("Hello world!")

FreeBASIC
? "Hello world!"
sleep

Frege
module HelloWorld where
main _ = println "Hello world!"

friendly interactive shell
echo Hello world!

Frink 
println["Hello world!"]
 
FunL
println( 'Hello world!' )

Furor
."Hello, World!\n"

FUZE BASIC
PRINT "Hello world!"

Gambas
Public Sub Main()
 
PRINT "Hello world!"
 
End

GAP
"Hello world!";
 
Print("Hello world!\n"); # No EOL appended
 
Display("Hello world!");
 
f := OutputTextUser();
WriteLine(f, "Hello world!\n");
CloseStream(f);

GB BASIC
10 print "Hello world!"

gecho
'Hello, <> 'World! print

Gema
*= ! ignore off content of input
\B=Hello world!\! ! Start output with this text.

Genie
init
    print "Hello world!"
 
Gentee
func hello <main>
{
   print("Hello world!")
}

GFA Basic
PRINT "Hello World"

GLBasic
STDOUT "Hello world!"

Glee
"Hello world!"

Global Script
λ _. print qq{Hello world!\n}

GlovePIE
debug="Hello world!"

GML
show_message("Hello world!"); // displays a pop-up message
show_debug_message("Hello world!"); // sends text to the debug log or IDE

Go
package main 
import "fmt"
func main() { fmt.Println("Hello world!") }

Golfscript
"Hello world!"

Gosu
print("Hello world!")

Groovy
println "Hello world!"

GW-BASIC
10 PRINT "Hello world!"

Hack
<?hh echo 'Hello world!'; ?>

Halon
echo "Hello world!";

Harbour
? "Hello world!"

Haskell
main = putStrLn "Hello world!"
 
Haxe
trace("Hello world!");

hexiscript
println "Hello world!"

HicEst
WRITE() 'Hello world!'

HLA
program goodbyeWorld;
#include("stdlib.hhf")
begin goodbyeWorld;
 
  stdout.put( "Hello world!" nl );
 
end goodbyeWorld;

HolyC
"Hello world!\n";

Hoon
~&  "Hello world!"  ~

HPPPL
PRINT("Hello world!");

Huginn
#! /bin/sh
exec huginn --no-argv -E "${0}" "${@}"
#! huginn
 
main() {
	print( "Hello World!\n" );
	return ( 0 );
}

HTML5
 
<!DOCTYPE html>
<html>
<body>
<h1>Hello world!</h1>
</body>
</html>
 
Hy
(print "Hello world!")

i
software {
    print("Hello world!")
}

Icon and Unicon
procedure main()
  write( "Hello world!" )
end

IDL
print,'Hello world!'

Inform 6
[Main;
  print "Hello world!^";
];

Inko
import std::stdio::stdout
 
stdout.print('Hello, world!')

Intercal
DO ,1 <- #13
PLEASE DO ,1 SUB #1 <- #238
DO ,1 SUB #2 <- #108
DO ,1 SUB #3 <- #112
DO ,1 SUB #4 <- #0
DO ,1 SUB #5 <- #64
DO ,1 SUB #6 <- #194
PLEASE DO ,1 SUB #7 <- #48
DO ,1 SUB #8 <- #26
DO ,1 SUB #9 <- #244
PLEASE DO ,1 SUB #10 <- #168
DO ,1 SUB #11 <- #24
DO ,1 SUB #12 <- #16
DO ,1 SUB #13 <- #162
PLEASE READ OUT ,1
PLEASE GIVE UP

Integer BASIC
   10 PRINT "Hello world!"
   20 END

Io
"Hello world!" println

Ioke
"Hello world!" println

IS-BASIC
PRINT "Hello world!"

Isabelle
theory Scratch
  imports Main
begin
  value ‹''Hello world!''›
end

IWBASIC
 
OPENCONSOLE
 
PRINT"Hello world!"
 
'This line could be left out.
PRINT:PRINT:PRINT"Press any key to end."
 
'Keep the console from closing right away so the text can be read.
DO:UNTIL INKEY$<>""
 
CLOSECONSOLE
 
END
 
J
   'Hello world!'

Jack
class Main {
  function void main () {
    do Output.printString("Hello world!");
    do Output.println();
    return;
  }
}

Jacquard Loom
+---------------+
|               |
|    *    *     |
|*   *    *  *  |
|*           * *|
|*           * *|
|*  *         * |
|   *     *   * |
|         *     |
+---------------+
 
+---------------+
|               |
|*   *    *     |
|*   *    *     |
|            * *|
|            * *|
|*  *         * |
|*  *     *   * |
|         *     |
+---------------+
 
+---------------+
|               |
|*   **   * *   |
|*******  *** * |
| **** *   * ***|
| **** *  ******|
| ******   ** * |
|   * *   *   * |
|         *     |
+---------------+
 
+---------------+
|               |
|*******  *** * |
|*******  *** * |
|           ** *|
|*        *  * *|
|*******   ** * |
|*******  *** * |
|         *     |
+---------------+
 
+---------------+
|               |
|*******  *** * |
|*******  *** * |
|      *  *  * *|
|      *  *  * *|
|*******  **  * |
|*******  **  * |
|         *     |
+---------------+
 
+---------------+
|               |
|***** *  *** * |
|*******  *** * |
|     * * *  *  |
|     * *    *  |
|******   **  * |
|******   **  * |
|         *     |
+---------------+
 
+---------------+
|               |
|    *    * *   |
|***** *  ***** |
|***** **  * ***|
|***** **  * ***|
|*******   * ** |
|   * *   *   * |
|         *     |
+---------------+
 
+---------------+
|               |
|               |
|     * *       |
|     * *       |
|     *         |
|     *         |
|               |
|               |
+---------------+

Java
public class HelloWorld
{
 public static void main(String[] args)
 {
  System.out.println("Hello world!");
 }
}

JavaScript
document.write("Hello world!");
console.log("Hello world!")

JCL
/*MESSAGE Hello world!

Jinja
from jinja2 import Template
print(Template("Hello World!").render())
 
Joy
"Hello world!" putchars.

jq
"Hello world!"

JSE
Print "Hello world!"

Jsish
puts("Hello world!")

Julia
println("Hello world!")

K
 
"Hello world!"
 
Kabap
return = "Hello world!";

Kaya
program hello;
 
Void main() {
    putStrLn("Hello world!");
}
 
Keg
Hello world\!

Kite
"#!/usr/local/bin/kite
 
"Hello world!"|print;

Kitten
"Hello world!" say

Koka
fun main() {
  println("Hello world!")
}

KonsolScript
function main() {
  Konsol:Log("Hello world!")
}

Kotlin
fun main() {
    println("Hello world!")
}

KQL
print 'Hello world!'

KSI
`plain
'Hello world!' #echo #
 
Lambdatalk 
Hello world!
{h1 Hello world!}
_h1 Hello world!\n
 
Lang5
"Hello world!\n" .

langur
writeln "yo, peeps"

Lasso
'Hello world!'

LATEX
\documentclass{minimal}
\begin{document}
Hello World!
\end{document}

Latitude
putln "Hello world!".

LC3 Assembly
.orig x3000
LEA R1, hello        ; R1 = &hello
TOP LDR R0, R1, #0   ; R0 = R1[0]
BRz END              ; if R0 is string terminator (x0000) go to END
TRAP x21             ; else OUT (write char in R0)
ADD R1, R1, #1       ;      increment R1
BR TOP               ;      go to TOP
END HALT
hello .stringz "Hello World!"
.end

LDPL
procedure:
display "Hello World!" crlf
 
LFE
(: io format '"Hello world!~n")
 
Liberty BASIC
print "Hello world!"

LIL
#
# Hello world in lil
#
 
print "Hello, world!"

Lily
stdout.print("Hello world!\n")

Lilypond
\version "2.18.2"
global = {
  \time 4/4
  \key c \major
  \tempo 4=100
}
\relative c''{ g e e( g2)
}
\addlyrics {
  Hel -- lo,   World!
}

Limbo
implement Command;
 
 include "sys.m";
     sys: Sys;
 
 include "draw.m";
 
 include "sh.m";
 
 init(nil: ref Draw->Context, nil: list of string)
 {
     sys = load Sys Sys->PATH;
     sys->print("Hello world!\n");
 }

Lingo
put "Hello world!"
trace("Hello world!")

Lisaac
Section Header          // The Header section is required.
  + name := GOODBYE2;   // Define the name of this object.
 
Section Public
  - main <- (IO.put_string "Hello world!\n";);

Little
puts("Hello world!");
puts(nonewline: "Hello world!");
puts(stderr, "Hello world!");

LiveCode
put "Hello World!"
Answer "Hello World!"

LLVM
; const char str[14] = "Hello World!\00"
@.str = private unnamed_addr constant  [14 x i8] c"Hello, world!\00"
 
; declare extern `puts` method
declare i32 @puts(i8*) nounwind
 
define i32 @main()
{
  call i32 @puts( i8* getelementptr ([14 x i8]* @str, i32 0,i32 0))
  ret i32 0
}

Lobster
print "Hello world!"

Logo
print [Hello world!]

Logtalk
:- object(hello_world).
 
    % the initialization/1 directive argument is automatically executed
    % when the object is loaded into memory:
    :- initialization(write('Hello world!\n')).
 
:- end_object.

LOLCODE
HAI
CAN HAS STDIO?
VISIBLE "Hello world!"
KTHXBYE
 
LotusScript
:- object(hello_world).
    'This will send the output to the status bar at the bottom of the Notes client screen
    print "Hello world!"
 
:- end_object.

LSE
AFFICHER [U, /] 'Hello world!'

LSE64
"Hello world!" ,t nl

Lua
local chars = {"G","o","o","d","b","y","e",","," ","W","o","r","l","d","!"}
for i = 1, #chars do
write(chars[i])
end
 
Luna
def main:
    hello = "Hello, World!"
    print hello

M2000 Interpreter 
Print "Hello World!" \\ printing on columns, in various ways defined by last $() for specific layer
Print $(4),"Hello World!" \\ proportional printing using columns, expanded to a number of columns as the length of string indicates.
Report "Hello World!"  \\ proportional printing with word wrap, for text, can apply justification and rendering a range of text lines
 
M4
`Hello world!'

Maclisp
(format t "Hello world!~%")

MAD
           VECTOR VALUES HELLO = $11HHELLO WORLD*$
           PRINT FORMAT HELLO
           END OF PROGRAM

make
all:
$(info Hello world!)

Malbolge
('&%:9]!~}|z2Vxwv-,POqponl$Hjig%eB@@>}=<M:9wv6WsU2T|nm-,jcL(I&%$#"
`CB]V?Tx<uVtT`Rpo3NlF.Jh++FdbCBA@?]!~|4XzyTT43Qsqq(Lnmkj"Fhg${z@>

MANOOL
{{extern; "manool.org.18/std/0.3/all"} in: WriteLine; Out; "Hello world!"}

Maple
> printf( "Hello world!\n" ): # print without quotes
Hello world!
 
Mathcad
"Hello, World!"

Mathematica / Wolfram Language
Print["Hello world!"]

MATLAB
>> disp('Hello world!')

Maude
fmod BYE-WORLD is
 
	protecting STRING .
 
	op sayBye : -> String .
 
	eq sayBye = "Hello world!" .
 
endfm
 
red sayBye .
 
Maxima
print("Hello world!");

MAXScript
print "Hello world!"

MDL
<PRINC "Hello world!">
<CRLF>

MelonBasic
Say:Hello world!

Mercury
:- module hello.
:- interface.
:- import_module io.
:- pred main(io::di, io::uo) is det.
 
:- implementation.
main(!IO) :-
    io.write_string("Hello world!\n", !IO).

Metafont
message "Hello world!"; end

min
"Hello world!" puts

MiniScript
print "Hello world!"

MiniZinc
output ["Hello World"];

MIPS Assembly
   .data #section for declaring variables
hello:  .asciiz "Hello world!" #asciiz automatically adds the null terminator. If it's .ascii it doesn't have it.
 
   .text # beginning of code
main: # a label, which can be used with jump and branching instructions.
   la $a0, hello # load the address of hello into $a0
   li $v0, 4 # set the syscall to print the string at the address $a0
   syscall # make the system call
 
   li $v0, 10 # set the syscall to exit
   syscall # make the system call

mIRC Scripting Language
echo -ag Hello world!

ML/I
Hello world!

Modula-2
MODULE Hello;
IMPORT InOut;
 
BEGIN
  InOut.WriteString('Hello world!');
  InOut.WriteLn
END Hello.

Modula-3
MODULE Goodbye EXPORTS Main;
 
IMPORT IO;
 
BEGIN
  IO.Put("Hello world!\n");
END Goodbye.

MontiLang
|Hello, World!| PRINT .

Morfa
import morfa.io.print;
func main(): void
{
    println("Hello world!");
}
 
Mosaic
proc start =
      println "Hello, world"
end

MUF
: main[ -- ]
me @ "Hello world!" notify
exit
;

MUMPS
Write "Hello world!",!

MyrtleScript
script HelloWorld {
    func main returns: int {
        print("Hello World!")
    }
}
 
MySQL
SELECT 'Hello world!';

Mythryl
print "Hello world!";

N/t/roff
Hello world!

Nanoquery
println "Hello world!"

Neat
void main() writeln "Hello world!";

Neko
$print("Hello world!");

Nemerle
class Hello
{
  static Main () : void
  {
    System.Console.WriteLine ("Hello world!");
  }
}

NetRexx
say  'Hello world!'

Never
func main() -> int {
    prints("Hello world!\n");
    0
}

newLISP
(println "Hello world!")

Nickle
printf("Hello world!\n")

Nim
echo("Hello world!")

Nit
print "Hello world!"

Nix
"Hello world!"

NS-HUBASIC
10 PRINT "HELLO WORLD!"

Nyquist
(print "Hello world!")

SAL syntax
exec format(t, "Hello World!")

Oberon-2
MODULE Goodbye;
IMPORT Out;
  PROCEDURE World*;
  BEGIN
    Out.String("Hello world!");Out.Ln
  END World;
BEGIN
  World;
END Goodbye.
 
Objeck
class Hello {
  function : Main(args : String[]) ~ Nil {
    "Hello world!"->PrintLine();
  }
}

Objective-C
#import <Foundation/Foundation.h> 
int main() {
    @autoreleasepool {
        NSLog(@"Hello, World!");
    }
}
 
OCaml
print_endline "Hello world!"

Occam
#USE "course.lib"
PROC main (CHAN BYTE screen!)
  out.string("Hello world!*c*n", 0, screen)
:

Octave
disp("Hello world!");

Odin
package main
import "core:fmt" 
main :: proc() {
  fmt.println("Hellope!");
}

Oforth
"Hello world!" .

Ol
(print "Hello world!")

Onyx
`Hello world!\n' print flush

OOC
main: func {
  "Hello world!" println()
}

ooRexx
say 'Hello world!'
 
OpenLisp
#!/openlisp/uxlisp -shell
(format t "Hello world!~%")
(print "Hello world!")

Openscad
 
echo("Hello world!");  // writes to the console
text("Hello world!");  // creates 2D text in the object space
linear_extrude(height=10) text("Hello world!"); // creates 3D text in the object space
 
Oxygene
namespace HelloWorld;
 
interface
 
type
  HelloClass = class
  public
    class method Main; 
  end;
 
implementation
 
class method HelloClass.Main;
begin
  System.Console.WriteLine('Hello world!');
end;
 
end.

Oz
{Show "Hello world!"}

PARI/GP
print("Hello world!")

Pascal
program byeworld;
begin
 writeln('Hello world!');
end.

PASM
print "Hello world!\n"
end

PDP-1 Assembly
hello   
/ above: title line - was punched in human readable letters on paper tape
/ below: location specifier - told assembler what address to assemble to
100/
lup,	lac i ptr		/ load ac from address stored in pointer
	cli			/ clear io register
lu2,	rcl 6s			/ rotate combined ac + io reg 6 bits to the left
				/ left 6 bits in ac move into right 6 bits of io reg
	tyo			/ type out character in 6 right-most bits of io reg
	sza			/ skip next instr if accumulator is zero
	jmp lu2			/ otherwise do next character in current word
	idx ptr			/ increment pointer to next word in message
	sas end			/ skip next instr if pointer passes the end of message
	jmp lup			/ otherwise do next word in message
	hlt			/ halt machine
ptr,	msg			/ pointer to current word in message
msg,	text "hello, world"	/ 3 6-bit fiodec chars packed into each 18-bit word
end,	.         		/ sentinel for end of message
start 100			/ tells assembler where program starts
 
PDP-11 Assembly
.globl  start
	.text
start:
        mov	$1,r0               / r0=stream, STDOUT=$1
	sys	4; outtext; outlen  / sys 4 is write
	sys	1                   / sys 1 is exit
	rts	pc                  / in case exit returns
 
	.data
outtext: <Hello world!\n>
outlen = . - outtext

PepsiScript
#include default-libraries
 
#author Childishbeat
 
class Hello world/Text:
function Hello world/Text:
 
print "Hello world!"
 
end

Perl
print "Hello world!\n";

Pharo
"Comments are in double quotes"
"Sending message printString to 'Hello World' string"
 
'Hello World' printString

Phix
puts(1,"Hello world!")

PHL
module helloworld;
extern printf;
 
@Integer main [
    printf("Hello world!");
    return 0;
]

PHP
<?php
echo "Hello world!\n";
?>

PicoLisp
(prinl "Hello world!")

Pict
new done: ^[]
run ( prNL!["Hello World!" (rchan done)]
    | done?_ = () )

Pikachu
pikachu pika pikachu pika pika pi pi pika pikachu pika pikachu pi pikachu pi pikachu pi pika pi pikachu pikachu pi pi pika pika pikachu pika pikachu pikachu pi pika pi pika pika pi pikachu pikachu pi pikachu pi pika pikachu pi pikachu pika pikachu pi pikachu pikachu pi pikachu pika pika pikachu pi pikachu pi pi pikachu pikachu pika pikachu pi pika pi pi pika pika pikachu pikachu pi pi pikachu pi pikachu
pikachu pikachu pi pikachu
pikachu pika pika pikachu pika pikachu pikachu pika pika pikachu pikachu pi pi pikachu pika pikachu pika pika pi pika pikachu pikachu pi pika pika pikachu pi pika pi pika pi pikachu pi pikachu pika pika pi pi pika pi pika pika pikachu pikachu pika pikachu pikachu pika pi pikachu pika pi pikachu pi pika pika pi pikachu pika pi pika pikachu pi pi pikachu pika pika pi pika pi pikachu
pikachu pikachu pi pikachu
pikachu pika pi pika pika pikachu pika pikachu pi pikachu pi pi pika pi pikachu pika pi pi pika pikachu pi pikachu pi pi pikachu pikachu pika pikachu pikachu pika pi pikachu pi pika pikachu pi pikachu pika pika pikachu pika pi pi pikachu pikachu pika pika pikachu pi pika pikachu pikachu pi pika pikachu pikachu pika pi pi pikachu pikachu pi pikachu pi pikachu pi pikachu pi pika pikachu pi pikachu pika pikachu pi pika pi pikachu
pi pika
pikachu pikachu pi pikachu
pika pi
pikachu pikachu pi pikachu
pikachu pi pikachu pi pi pikachu pi pikachu pika pikachu pikachu pi pikachu pikachu pika pi pi pika pikachu pika pikachu pi pi pikachu pika pi pi pikachu pika pika pi pika pika pikachu pika pikachu pi pi pika pikachu pika pi pikachu pikachu pi pikachu pika pikachu pikachu pika pi pi pikachu pikachu pi pika pikachu pi pikachu pika pikachu pikachu pika pi pikachu pikachu pika pikachu pi pikachu pika pika pi pikachu pi pika pi pikachu pikachu pi pikachu
pi pika
pikachu pikachu pi pikachu
pikachu pikachu pi pika pikachu pi pika pika pi pi pika pi pikachu pi pika pi pika pi pika pikachu pika pi pi pikachu pi pikachu pi pika pi pika pika pikachu pi pikachu
pikachu pikachu pi pikachu
pikachu pi pikachu pika pikachu pi pika pi pikachu pikachu pika pika pi pi pikachu pi pika pi pikachu pi pika pikachu pi pika pi pi pikachu pikachu pika pika pikachu pikachu pi pi pikachu pi pikachu pi pikachu pi pi pikachu pikachu pi pikachu pi pikachu pi pika pika pikachu pikachu pika pi pika pikachu pi pikachu pi pi pika pikachu pika pi pikachu pi pika pi pi pikachu pikachu pika pika pikachu pika pika pikachu pi pika pi pika pikachu pi pika pikachu pika pi pika pikachu
pikachu pikachu pika pikachu
pikachu pikachu pika pikachu
pi pi pikachu pi pikachu pika pika pi pikachu pika pika pi pi pika pika pikachu pi pi pikachu pi pika pi pika pikachu pi pikachu pi pikachu pikachu pi pi pika pika pi pika pika pi pika pikachu pikachu pi pikachu pika pi pi pika pi pi pikachu pikachu pika pi pi pika pika pi pika pikachu pi pikachu pi pi pika pi pika pika pikachu pika pi pika pikachu pi pikachu pikachu pi pi pika pi pika pika pikachu pikachu pi pikachu
pikachu pikachu pi pikachu
pikachu pi pikachu pikachu pika pikachu pikachu pika pika pikachu pikachu pika pikachu pi pika pikachu pika pika pi pikachu pi pi pika pi pi pikachu pika pika pikachu pikachu pika pikachu pikachu pi pika pi pi pikachu pikachu pika pi pi pikachu pikachu pika pikachu pika pi pikachu pi pika pi pika pikachu pika pi pikachu pi pikachu pikachu pi pika pikachu pi pikachu pikachu pi pika pi pikachu pikachu pi pikachu pika pika pi pi pikachu
pikachu pi pi pika pi pi pikachu pika pikachu pikachu pika pika pi pi pika pikachu pi pikachu pi pi pika pi pika pi pi pika pikachu pi pika pi pikachu pika pikachu pika pi pi pika pi pi pikachu pi pikachu pikachu pika pi pikachu pi pi pika pi pikachu pi pi pika pi pi pikachu pika pikachu pika pikachu pika pi pikachu pikachu pi pi pika pika pikachu
pikachu pikachu pi pikachu
pikachu pikachu pika pikachu

Pike
int main(){
   write("Hello world!\n");
}

PILOT
T:Hello world!

PIR
.sub hello_world_text :main
	print "Hello world!\n"
.end

Pixilang
fputs("Hello world!\n")

PL/I
goodbye:proc options(main);
     put list('Hello world!');
end goodbye;

PL/M
100H:
   /* CP/M BDOS SYSTEM CALL */
   BDOS: PROCEDURE( FN, ARG ); DECLARE FN BYTE, ARG ADDRESS; GOTO 5; END;
   /* PRINT A $ TERMINATED STRING */
   PRINT$STRING: PROCEDURE( S ); DECLARE S ADDRESS; CALL BDOS( 9, S ); END;
   /* HELLO, WORLD! IN MIXED CASE */
   DECLARE HELLO$WORLD ( 14 ) BYTE
           INITIAL( 'H', 65H, 6CH, 6CH, 6FH, ',', ' '
                  , 'W', 6FH, 72H, 6CH, 64H, 21H, '$'
                  );
   CALL PRINT$STRING( .HELLO$WORLD );
EOF

PL/SQL
SET serveroutput ON
 
BEGIN
  DBMS_OUTPUT.PUT_LINE('Hello world!');
END;
/                                                                   

Plain English
\This prints Hello World within the CAL-4700 IDE.
\...and backslashes are comments!
To run:
Start up.
Write "Hello World!" to the console.
Wait for the escape key.
Shut down.

Plan
#STEER         LIST,BINARY
#PROGRAM       HLWD
#LOWER
MSG1A          11HHELLO WORLD
MSG1B          11/MSG1A
#PROGRAM
#ENTRY         0
      DISTY    MSG1B
      SUSWT    2HHH
#END
#FINISH
#STOP

Pony
actor Main
  new create(env: Env) =>
    env.out.print("Hello world!")

Pop11
printf('Hello world!\n');

PostScript
%!PS
/Helvetica 20 selectfont
70 700 moveto
(Hello world!) show
showpage

Potion
"Hello world!\n" print

PowerBASIC
#COMPILE EXE
#COMPILER PBCC 6
 
FUNCTION PBMAIN () AS LONG
  CON.PRINT "Hello world!"
  CON.WAITKEY$
END FUNCTION

PowerShell
'Hello world!'

Processing
println("Hello world!");

ProDOS
printline Hello world!

Programming Language
print(Hello world!)
[print(Hello world!)]

Prolog
:- write('Hello world!'), nl.

PSQL
 EXECUTE BLOCK
   RETURNS(S VARCHAR(40))
 AS
 BEGIN
   S = 'Hello world!';
   SUSPEND;
 END

Pure
using system;
 
puts "Hello world!\n" ;
 
PureBasic
OpenConsole()
PrintN("Hello world!")
Input() ; Wait for enter

Python
print "Hello world!"
import sys
sys.stdout.write("Hello world!\n")
import __hello__
import __phello__

QB64
PRINT "Hello world!"

Quackery
say "Hello world!"

Quill
"Hello world!" print

Quite BASIC
10 print "Hello world!"

R
 cat("Hello world!\n")

Ra
class HelloWorld
	**Prints "Hello world!"**
 
	on start
 
		print "Hello world!"
 
Racket 
(printf "Hello world!\n")
 
Raku
"Hello, World!".say();

Raven
'Hello world!' print

RASEL
A"!dlroW ,olleH">:?@,Hj

REALbasic
Function Run(args() as String) As Integer
  Print "Hello world!"
  Quit
End Function

REBOL
print "Hello world!"

RED
print "Hello world!"

Retro
'Hello_world! s:put
 
Relation
' Hello world!
 
REXX
say 'Hello world!'
yyy = 'Hello world!'
say yyy
call lineout ,"Hello world!"

Ring
See "Hello world!"

Risc-V
.data
hello:
.string "Hello World!\n\0"
.text
main:
la a0, hello
li a7, 4
ecall
li a7, 10
ecall
 
RTL/2
TITLE Goodbye World;
 
LET NL=10;
 
EXT PROC(REF ARRAY BYTE) TWRT;
 
ENT PROC INT RRJOB();
 
    TWRT("Hello world!#NL#");
    RETURN(1);
 
ENDPROC;

Ruby
puts "Hello world!"

Run BASIC
print "Hello world!"

Rust 
fn main() {
   println!("Hello world!");
}
 
Salmon
"Hello world!"!

SAS
data _null_;
put "Hello world!";
run;

SASL
'Hello World!",nl
 
Sather
class GOODBYE_WORLD is
 main is 
  #OUT+"Hello world!\n"; 
 end; 
end;

Scheme
"Hello world!"

R5RS
(display "Hello world!")
(newline)

R6RS
(import (rnrs base (6))
        (rnrs io simple (6)))
(display "Hello world!")
(newline)

R7RS
(import (scheme base)
        (scheme write))
(display "Hello world!")
(newline)

Scilab
disp("Hello world!");

ScratchScript
print "Hello world!"
delayOnClick

sed
i\
Hello world!
q

Seed7
$ include "seed7_05.s7i";
 
const proc: main is func
  begin
    writeln("Hello world!");
  end func;

Self
'Hello world!' printLine.

SenseTalk
put "Hello world!"

Set lang
set ! H
set ! E
set ! L
set ! L
set ! O
set ! 32
set ! W
set ! O
set ! R
set ! L
set ! D
set ! 33

SETL
print("Hello world!");

SETL4
out("Hello world!");end

Shen
(output "Hello world!~%")

Shiny
say 'Hello world!'

Sidef
„Hello world!”.say;

SimpleCode
dtxt
Hello world!

SIMPOL
function main()
end function "Hello world!{d}{a}"

Simula
BEGIN
   OUTTEXT("Hello world!");
   OUTIMAGE
END

Sing
requires "sio";
 
public fn singmain(argv [*]string) i32
{
    sio.print("hello world !\r\n");
    return(0);
}

Sisal
define main
 
% Sisal doesn't yet have a string built-in.
% Let's define one as an array of characters.
 
type string = array[character];
 
function main(returns string)
  "Hello world!"
end function

SkookumScript
print("Hello world!")

Slate
inform: 'Hello world!'.

Smalltalk
'Hello world!' printNl.

smart BASIC
PRINT "Hello world!"

SmileBASIC
PRINT "Hello world!"

SNOBOL4
    OUTPUT = "Hello world!"
END

SNUSP
Core SNUSP
/++++!/===========?\>++.>+.+++++++..+++\
\+++\ | /+>+++++++>/ /++++++++++<<.++>./
$+++/ | \+++++++++>\ \+++++.>.+++.-----\
      \==-<<<<+>+++/ /=.>.+>.--------.-/

Modular SNUSP
@\G.@\o.o.@\d.--b.@\y.@\e.>@\comma.@\.<-@\W.+@\o.+++r.------l.@\d.>+.! #
 |   |     \@------|#  |    \@@+@@++|+++#-    \\               -
 |   \@@@@=+++++#  |   \===--------!\===!\-----|-------#-------/
 \@@+@@@+++++#     \!#+++++++++++++++++++++++#!/

SoneKing Assembly 
extern print
 
dv Msg Goodbye,World!
 
mov eax Msg
push
call print
pop
 
SPARC Assembly
 
	.section	".text"
	.global		_start
_start:
	mov	4,%g1			! 4 is SYS_write
	mov	1,%o0			! 1 is stdout
	set	.msg,%o1		! pointer to buffer
	mov	(.msgend-.msg),%o2	! length
	ta	8
 
	mov	1,%g1			! 1 is SYS_exit
	clr	%o0			! return status is 0
	ta	8
 
.msg:
	.ascii	"Hello world!\n"
.msgend:
 
Sparkling
print("Hello world!");

SPL
#.output("Hello world!")

SQL
SELECT 'Hello world!' text FROM dual;
 
SQL PL
SELECT 'Hello world!' AS text FROM sysibm.sysdummy1;

Standard ML
print "Hello world!\n"

Stata
display "Hello world!"

Suneido
Print("Hello world!")

Swahili
andika("Hello world!")

Swift
println("Hello world!")

Symsyn
 'hello world' []
 
Tailspin
'Hello World' -> !OUT::write

Tcl
puts $fileID "Hello world!"

Teco
^AHello world!^A$$

Tern
println("Hello world!");

Terra
C = terralib.includec("stdio.h")
 
terra hello(argc : int, argv : &rawstring)
  C.printf("Hello world!\n")
  return 0
end

Terraform
output "result" {
  value = "Hello world!"
}

TestML
%TestML 0.1.0
Print("Hello world!")

TI-83 BASIC
Disp "Hello world!

TI-89 BASIC
Disp "Hello world!"

Tiny BASIC
10 PRINT "Hello, World!"
 
TMG
begin: parse(( = { <Hello, World!> * } ));

TorqueScript
echo("Hello world!");

TPP
Hello world!

Transact-SQL
PRINT "Hello world!"

Transd
(textout "Hello, World!")

TransFORTH
PRINT " Hello world! "

Trith
"Hello world!" print

True BASIC
! In True BASIC all programs run in their own window. So this is almost a graphical version.
PRINT "Hello world!"
END
 
TUSCRIPT
$$ MODE TUSCRIPT
PRINT "Hello world!"

Uniface
message "Hello world!"
 
Unison
main = '(printLine "Hello world!")
 
UNIX Shell
#!/bin/sh
echo "Hello world!"

Unlambda
`r```````````````.G.o.o.d.b.y.e.,. .W.o.r.l.d.!i

Ursa
out "hello world!" endl console

Ursala
#import std
 
#executable ('parameterized','')
 
main = <file[contents: -[Hello world!]-]>!

V
"Hello world!" puts

Vala
void main(){
	stdout.printf("Hello world!\n");
}

VAX Assembly
desc:  .ascid "Hello World!"      ;descriptor (len+addr) and text
.entry hello, ^m<>                ;register save mask
       pushaq desc                ;address of descriptor
       calls #1, g^lib$put_output ;call with one argument on stack
       ret                        ;restore registers, clean stack & return
.end hello                        ;transfer address for linker
 
VBA 
Public Sub hello_world_text
    Debug.Print "Hello World!"
End Sub 

VBScript
WScript.Echo "Hello world!"

Vedit macro language
Message("Hello world!")

Verbexx
@SAY "Hello world!";

Verilog
module main;
  initial begin
      $display("Hello world!");
      $finish ;
    end
endmodule
 
VHDL
LIBRARY std;
USE std.TEXTIO.all;
 
entity test is
end entity test;
 
architecture beh of test is
begin
  process
    variable line_out : line;
  begin
    write(line_out, string'("Hello world!"));
    writeline(OUTPUT, line_out);
    wait; -- needed to stop the execution
  end process;
end architecture beh;

Vim Script
echo "Hello world!\n"

Visual Basic
Option Explicit
 
Private Declare Function AllocConsole Lib "kernel32.dll" () As Long
Private Declare Function FreeConsole Lib "kernel32.dll" () As Long
'needs a reference set to "Microsoft Scripting Runtime" (scrrun.dll)

Sub Main()
  Call AllocConsole
  Dim mFSO As Scripting.FileSystemObject
  Dim mStdIn As Scripting.TextStream
  Dim mStdOut As Scripting.TextStream
  Set mFSO = New Scripting.FileSystemObject
  Set mStdIn = mFSO.GetStandardStream(StdIn)
  Set mStdOut = mFSO.GetStandardStream(StdOut)
  mStdOut.Write "Hello world!" & vbNewLine
  mStdOut.Write "press enter to quit program."
  mStdIn.Read 1
  Call FreeConsole
End Sub

Visual Basic .NET
Imports System
 
Module HelloWorld
    Sub Main()
        Console.WriteLine("Hello world!")
    End Sub
End Module

Viua VM assembly
.function: main/0
    text %1 local "Hello World!"
    print %1 local
    izero %0 local
    return
.end

Vlang
fn main() {
        println('Hello World!')
}

Wart
prn "Hello world!"

WDTE
io.writeln io.stdout 'Hello world!';

WebAssembly
Library: WASI
(module $helloworld
 
    ;;Import fd_write from WASI, declaring that it takes 4 i32 inputs and returns 1 i32 value
    (import "wasi_unstable" "fd_write"
        (func $fd_write (param i32 i32 i32 i32) (result i32))
    )
 
    ;;Declare initial memory size of 32 bytes
    (memory 32)
 
    ;;Export memory so external functions can see it
    (export "memory" (memory 0))
 
    ;;Declare test data starting at address 8
    (data (i32.const 8) "Hello world!\n")
 
    ;;The entry point for WASI is called _start
    (func $main (export "_start")
 
        ;;Write the start address of the string to address 0
        (i32.store (i32.const 0) (i32.const 8)) 
 
        ;;Write the length of the string to address 4
        (i32.store (i32.const 4) (i32.const 13))
 
        ;;Call fd_write to print to console
        (call $fd_write
            (i32.const 1) ;;Value of 1 corresponds to stdout
            (i32.const 0) ;;The location in memory of the string pointer
            (i32.const 1) ;;Number of strings to output
            (i32.const 24) ;;Address to write number of bytes written
        )
        drop ;;Ignore return code
    )
)
 
Wee Basic
print 1 "Hello world!"
end

Whenever
1 print("Hello world!");

Whiley
import whiley.lang.System
 
method main(System.Console console):
    console.out.println("Hello world!")

Wisp
import : scheme base
         scheme write
display "Hello world!"
newline

Wolfram Language
Print["Hello world!"]

Wren
System.print("Hello world!")

X86 Assembly
section .data
msg     db      'Hello world!', 0AH
len     equ     $-msg
 
section .text
global  _start
_start: mov     edx, len
        mov     ecx, msg
        mov     ebx, 1
        mov     eax, 4
        int     80h
 
        mov     ebx, 0
        mov     eax, 1
        int     80h

X86-64 Assembly
option casemap:none
if @Platform eq 1
   option dllimport:<kernel32>
      ExitProcess   proto :dword
   option dllimport:none
      exit          equ ExitProcess
endif
printf              proto :qword, :vararg
exit                proto :dword
 
.code
main proc
invoke printf, CSTR("Goodbye, World!",10)
invoke exit, 0
ret
main endp
end
 
XBasic
PROGRAM "hello"
VERSION "0.0003"
 
DECLARE FUNCTION Entry()
 
FUNCTION Entry()
  PRINT "Hello World"
END FUNCTION
END PROGRAM
 
xEec 
h#10 h$! h$d h$l h$r h$o h$w h#32  
h$o h$l h$l h$e h$H >o o$ p jno
 
XL
use XL.UI.CONSOLE
WriteLn "Hello world!"

XLISP
(DISPLAY "Hello world!")
(NEWLINE)

XPL0
code Text=12;
Text(0, "Hello world!
")

XSLT
<xsl:text>Hello world!
</xsl:text>

Yabasic 
print "Hello world!"
 
Yorick
write, "Hello world!"

Z80 Assembly
org		$4000
 
txt_output:	equ	$bb5a
 
		push	hl
		ld	hl,world
 
print:		ld	a,(hl)
		cp	0
		jr	z,end
		call	txt_output
		inc	hl
		jr	print
 
end:		pop	hl
		ret
 
world:		defm	"Hello world!\r\n\0"

zkl
println("Hello world!");

Zoea
program: hello_world 
  output: "Hello  world!"

Zoomscript
print "Hello world!"

ZX Spectrum Basic
10 PRINT "Hello world!"